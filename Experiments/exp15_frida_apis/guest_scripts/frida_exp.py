# -*- coding: utf-8 -*-
from __future__ import print_function

import threading
import time
import os

import frida  # pylint: disable=import-error
from frida_tools.application import Reactor  # pylint: disable=import-error

from generate_js import generate_js


class Logger():

    def __init__(self, skip_first_process=False):
        # Pid to file object dictionary
        self.pid_table = {}
        # Skip the launcher process if necessary
        self.skip = skip_first_process

    def log(self, pid, *args):
        file = None
        if pid in self.pid_table:
            file = self.pid_table[pid]
        elif len(self.pid_table) == 0 and self.skip:
            file = open(os.devnull, 'w')
            self.pid_table[pid] = file
        else:
            file = open(f"./exp/frida_{pid}", 'w')
            self.pid_table[pid] = file
        timestamp = time.time()
        file.write(f"{timestamp}," + ','.join(args) + '\n')
        file.flush()


class Application(object):
    def __init__(self):
        self._stop_requested = threading.Event()
        self._reactor = Reactor(run_until_return=lambda reactor: self._stop_requested.wait())

        self._device = frida.get_local_device()
        self._sessions = set()

        self._device.on("child-added", lambda child: self._reactor.schedule(lambda: self._on_child_added(child)))
        self._device.on("child-removed", lambda child: self._reactor.schedule(lambda: self._on_child_removed(child)))
        self._device.on("output", lambda pid, fd, data: self._reactor.schedule(lambda: self._on_output(pid, fd, data)))

        self.logger = Logger(True)

    def run(self):
        self._reactor.schedule(lambda: self._start())
        self._reactor.run()

    def _start(self):
        argv = [r"C:\Users\nima\AppData\Local\Programs\Python\Python37\python.exe", r"C:/Users/nima/Desktop/launcher.py"]
        env = {
        }
        print("✔ spawn(argv={})".format(argv))
        pid = self._device.spawn(argv, env=env, stdio='pipe')
        self._instrument(pid)

    def _stop_if_idle(self):
        if len(self._sessions) == 0:
            self._stop_requested.set()

    def _instrument(self, pid):
        print("✔ attach(pid={})".format(pid))
        session = self._device.attach(pid)
        session.on("detached", lambda reason: self._reactor.schedule(lambda: self._on_detached(pid, session, reason)))
        print("✔ enable_child_gating()")
        session.enable_child_gating()
        print("✔ create_script()")
        script = session.create_script(generate_js("./new_api_list.txt"))
        script.on("message", lambda message, data: self._reactor.schedule(lambda: self._on_message(pid, message)))
        print("✔ load()")
        script.load()
        print("✔ resume(pid={})".format(pid))
        self._device.resume(pid)
        self._sessions.add(session)

    def _on_child_added(self, child):
        print("⚡ child_added: {}".format(child))
        self._instrument(child.pid)

    def _on_child_removed(self, child):
        print("⚡ child_removed: {}".format(child))

    def _on_output(self, pid, fd, data):
        print("⚡ output: pid={}, fd={}, data={}".format(pid, fd, repr(data)))

    def _on_detached(self, pid, session, reason):
        print("⚡ detached: pid={}, reason='{}'".format(pid, reason))
        self._sessions.remove(session)
        self._reactor.schedule(self._stop_if_idle, delay=0.5)

    def _on_message(self, pid, message):
        try:
            api_name = message['payload']['api_name']
            category = message['payload']['category']
            self.logger.log(pid, api_name, category)
        except KeyError:
            print(message)


if __name__ == '__main__':
    app = Application()
    app.run()
