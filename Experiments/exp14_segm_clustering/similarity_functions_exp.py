from Levenshtein import distance as lavenstein

def jaccard(str1, str2): 
    a = set(list(str1)) 
    b = set(list(str2))
    c = a.intersection(b)
    return float(len(c)) / float(len(a) + len(b) - len(c))

def vlvd(str1, str2):
    l1 = len(str1)
    l2 = len(str2)
    inter = set(list(str1)).intersection(set(list(str2)))
    return (l1 + l2 - 2*len(inter)) / (l1 + l2)

print(lavenstein("aaa", "aaaaaa"))

#ngrams
#https://stackoverflow.com/questions/2380394/simple-implementation-of-n-gram-tf-idf-and-cosine-similarity-in-python

#https://tiefenauer.github.io/blog/smith-waterman/
import itertools
import numpy as np

def matrix(a, b, match_score=3, gap_cost=2):
    H = np.zeros((len(a) + 1, len(b) + 1), np.int)

    for i, j in itertools.product(range(1, H.shape[0]), range(1, H.shape[1])):
        match = H[i - 1, j - 1] + (match_score if a[i - 1] == b[j - 1] else - match_score)
        delete = H[i - 1, j] - gap_cost
        insert = H[i, j - 1] - gap_cost
        H[i, j] = max(match, delete, insert, 0)
    return H

def traceback(H, b, b_='', old_i=0):
    # flip H to get index of **last** occurrence of H.max() with np.argmax()
    H_flip = np.flip(np.flip(H, 0), 1)
    i_, j_ = np.unravel_index(H_flip.argmax(), H_flip.shape)
    i, j = np.subtract(H.shape, (i_ + 1, j_ + 1))  # (i, j) are **last** indexes of H.max()
    if H[i, j] == 0:
        return b_, j
    b_ = b[j - 1] + '-' + b_ if old_i - i > 1 else b[j - 1] + b_
    return traceback(H[0:i, 0:j], b, b_, i)

def smith_waterman(a, b, match_score=3, gap_cost=2):
    a, b = a.upper(), b.upper()
    H = matrix(a, b, match_score, gap_cost)
    b_, pos = traceback(H, b)
    return pos, pos + len(b_)

# prints correct scoring matrix from Wikipedia example
print(matrix('GGTTGACTA', 'TGTTACGG'))

a, b = 'ggttgacta', 'tgttacgg'
H = matrix(a, b)
print(traceback(H, b)) # ('gtt-ac', 1)

a, b = 'AAABAAAAAAA', 'AAAAAAA'
start, end = smith_waterman(a, b)
print(a[start:end])     # GTTGAC
print(end-start)
l1, l2 = len(a), len(b)
#Sequence Alignment Based Distance Measure (SABDM)
sim = (max(l1, l2) - (end - start)) / max(l1, l2)
print(1 - sim)

import numpy as np
from scipy.spatial.distance import euclidean

from fastdtw import fastdtw
def custom_dist(a,b):
    return a!=b

a = [ord(i) for i in a]
b = [ord(i) for i in b]

dtw_distance, warp_path = fastdtw(list(a), list(b), dist=custom_dist)
sim = (max(l1, l2) - dtw_distance) / max(l1, l2)

print(sim)