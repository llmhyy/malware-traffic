# Experiment 2

For this experiment, we'll once again use metasploit to generate a malicious executable.
This time, we'll also instrument the executable with Pin in order to see if we can link a function call to network activities.
- Victim address : 10.0.2.15
- Attacker address : 10.0.2.5

## Goals :
We will sniff the traffic on the victim computer as well as the function calls of the executable thanks to Pin in order to understand how this malicious software proceeds in term of network activity related to function calls.

## Procedure :
* The attacker and the victim are in a same local network. 
* On the attacker VM, we set metasploit to listen to the network as a server for the malicious executable.
* On the victim VM, we launch Wireshark to record the traffic on the corresponding interface.
* On the victim VM, we launch the malicious executable with Pin and myPinTool privided by Jun Yang.
* On the attacker VM, the metasploit listener connects to the malicious software and gives us a reverse shell.
* With seconds between, we type and run these commands in the reverse shell :
    - ls
    - cd ../
    - ls
    - load kiwi
    - deconnection with Ctrl-D
* On the victim VM, we save the Wireshark record in a pcap file and verify that the output of Pin is present.

## Analysis :
Let's examine the output of Pin :
```
#
# Function Trace Generated By Pin
#
Time: 19-09-2020 22:28:25 Img: C:\Users\nima\Desktop\shell.exe Addr: 0x400000
```
Basicaly, Pin did not record any function call. To check if it's an error from the myPinTool or not, I tested the same tool with Internet Explorer. Here is the resulting file :
```
#
# Function Trace Generated By Pin
#
Time: 19-09-2020 22:55:48 Img: C:\Program Files (x86)\Internet Explorer\iexplore.exe Addr: 0x6d0000
JUMP DETECTED at 0x36e0 ReturnAddr: 0x36e5
Time : 19-09-2020 22:55:48 IMG_Name : C:\Program Files (x86)\Internet Explorer\iexplore.exe FUNCTION: 3bb5
Time : 19-09-2020 22:55:48 IMG_Name : C:\Program Files (x86)\Internet Explorer\iexplore.exe INS_OFFSET: 0x3bb7
Time : 19-09-2020 22:55:48 IMG_Name : C:\Program Files (x86)\Internet Explorer\iexplore.exe INS_OFFSET: 0x3bb8
Time : 19-09-2020 22:55:48 IMG_Name : C:\Program Files (x86)\Internet Explorer\iexplore.exe INS_OFFSET: 0x3bba
Time : 19-09-2020 22:55:48 IMG_Name : C:\Program Files (x86)\Internet Explorer\iexplore.exe INS_OFFSET: 0x3bbd
......
```
We can conclude that the Pin instrumentation is well functioning. However, it did not work on this executable.
I will not explore the reasons as we are most interested in real malwares than this toy one.

To get something out this experiment, I wrote a Python script to automatically segment the different parts of the network recording. 

To do so, we basically do the following. We proceed each packet one after an other. If the current packet is fairly close in terms of time than the previous one, then we put in the same group than the previous one. If it's not, we close the previous group and create a new one with the current packet.

The challenge is to define "fairly close". We can manually set a threshold of inter-packet time to solve this issue. As I wanted a more automatic method, I did the following :
- create a list of the consecutive packets inter-timing (e.g. a list with `t[i+1] - t[i]`, where i is the index of the current packet and t[] the array with the time of recording of the packet i)
- run a k-means algorithm with k=2 on this list. The 2 groups we are getting is the sufficiently-close inter-packet times and the not-sufficiently close one

Let's see the result on our network record :

<img src="result.png" width="1000">

The different colors represent the different groups of packet. The method seems to work well. However, its robustness in real scenarios is still to be proven.

## Conclusion :
Instrumenting this toy malware was a failure. Further investigations would be necessary to understand why.

However, we managed to create an automated way to group the different groups of packets that correspond to an action.