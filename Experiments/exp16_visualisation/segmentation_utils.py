from scapy.all import *
from scapy.layers.inet import IP, TCP
import matplotlib.pyplot as plt
import numpy as np
from typing import List, Iterable


def relative_time(timestamp: int) -> int:
	"""
	[Depreciated feature but still used] used to start time from 0
	Not applicable when we map API calls
	:param timestamp:
	:return:
	"""
	# return int(timestamp-time_origin)
	return int(timestamp)


def detect_correct_handshake(pck_list: List[Packet]) -> List:
	"""
	Handshake detection
	:param pck_list:
	:return:
	"""
	return_list = []
	for i in range(2, len(pck_list)):
		if pck_list[i - 2][TCP].flags == 0x2 and pck_list[i - 1][TCP].flags == 0x12 and pck_list[i][
			TCP].flags == 0x10:
			handshake_time_interval = [relative_time(
				pck_list[i - 2].time * 1000000), relative_time(pck_list[i].time * 1000000)]
			return_list.append(["HANDSHAKE", [i - 2, i], handshake_time_interval])
	return return_list


def detect_failed_handshake(pck_list: List[Packet]) -> List:
	"""
	Failed handshake detection
	:param pck_list:
	:return:
	"""
	return_list = []
	first_i = -1
	in_progress = 0
	for i in range(len(pck_list)):
		if pck_list[i][TCP].flags == 0x2:
			if not in_progress:
				in_progress = 1
				first_i = i
		elif pck_list[i][TCP].flags == 0x14:
			if in_progress:
				handshake_time_interval = [relative_time(
					pck_list[first_i].time * 1000000), relative_time(pck_list[i].time * 1000000)]
				return_list.append(
					["HANDSHAKE_FAILED", [first_i, i], handshake_time_interval])
				in_progress = 0
		elif pck_list[i][TCP].flags == 0x12 or pck_list[i][TCP].flags == 0x11:
			in_progress = 0
		"""else:
            if in_progress:
                return_list.append(["HANDSHAKE_FAILED", [first_i, i-1]])
                in_progress = 0"""
	if in_progress:
		handshake_time_interval = [relative_time(pck_list[first_i].time * 1000000),
		                           relative_time(pck_list[len(pck_list) - 1].time * 1000000)]
		return_list.append(
			["HANDSHAKE_FAILED", [first_i, len(pck_list) - 1], handshake_time_interval])
	return return_list


def detect_fin(pck_list: List[Packet], last_handshake_packet: int) -> List:
	"""
	End detection
	:param pck_list:
	:param last_handshake_packet: index of the last packet from TCP handshake, starting point to search termination
	:return:
	"""
	return_list = []
	for i in range(last_handshake_packet + 1 + 3, len(pck_list)):
		if pck_list[i - 3][TCP].flags == 0x11 and pck_list[i - 2][TCP].flags == 0x10 and pck_list[i - 1][
			TCP].flags == 0x11 and pck_list[i][TCP].flags == 0x10:
			time = [relative_time(
				pck_list[i - 3].time * 1000000), relative_time(pck_list[i].time * 1000000)]
			return_list.append(["TERM", [i - 3, i], time])
	return return_list


def detect_rst_fin(pck_list: List[Packet], last_handshake_packet: int) -> List:
	"""
	Rst End detection
	:param pck_list:
	:param last_handshake_packet: index of the last packet from TCP handshake, starting point to search termination
	:return:
	"""
	return_list = []
	for i in range(last_handshake_packet + 1, len(pck_list)):
		if pck_list[i][TCP].flags == 0x04 or pck_list[i][TCP].flags == 0x14:
			time = relative_time(pck_list[i].time * 1000000)
			return_list.append(["TERM_RST", [i, i], [time, time]])
	return return_list
