# Dynamic programming implementation of LCS problem
# This code is contributed by BHAVYA JAIN
# Returns length of LCS for X[0..m-1], Y[0..n-1]
# https://www.geeksforgeeks.org/printing-longest-common-subsequence/

def lcs(X, Y):
	m = len(X)
	n = len(Y)
	L = [[0 for x in range(n + 1)] for x in range(m + 1)]
	
	# Following steps build L[m+1][n+1] in bottom up fashion. Note
	# that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1]
	for i in range(m + 1):
		for j in range(n + 1):
			if i == 0 or j == 0:
				L[i][j] = 0
			elif X[i - 1] == Y[j - 1]:
				L[i][j] = L[i - 1][j - 1] + 1
			else:
				L[i][j] = max(L[i - 1][j], L[i][j - 1])
	
	# Following code is used to print LCS
	index = L[m][n]
	
	# Create a character array to store the lcs string
	lcs = [""] * (index + 1)
	lcs[index] = ""
	
	# Start from the right-most-bottom-most corner and
	# one by one store characters in lcs[]
	i = m
	j = n
	while i > 0 and j > 0:
		
		# If current character in X[] and Y are same, then
		# current character is part of LCS
		if X[i - 1] == Y[j - 1]:
			lcs[index - 1] = X[i - 1]
			i -= 1
			j -= 1
			index -= 1
		
		# If not same, then find the larger of two and
		# go in the direction of larger value
		elif L[i - 1][j] > L[i][j - 1]:
			i -= 1
		else:
			j -= 1
	return lcs


def n_lcs(args):
	lcs_result = lcs(args[0], args[1])
	for arg in args[2:]:
		lcs_result = lcs(lcs_result, arg)
	return lcs_result


if __name__ == "__main__":
	# Driver program
	X = "AAAAAABC"
	Y = "AAAAAADC"
	Z = "EEEEEEEFC"
	m = len(X)
	n = len(Y)
	o = len(Z)
	i = lcs(X, Y)
	print(lcs(i, Z))
	print(n_lcs(X, Y, Z))