# Dynamic programming implementation of LCS problem
# This code is contributed by BHAVYA JAIN
# Returns length of LCS for X[0..m-1], Y[0..n-1]
# https://www.geeksforgeeks.org/printing-longest-common-subsequence/

import pylcs
from comparaison_classes import Singleton


class LCS(metaclass=Singleton):
	"""
	Class to compute the LCS (real one) for n string (or 2)
	WARNING: the previous classes were taking lists of elements as inputs, and then preprocessed them internally to strings.
	The lcs similarity score is calculated on strings.
	This class however operates on list of ints (TODO: type hinting)
	The preprocessing is not done here but manually, before, by the Api2Listofint class.
	This is inconsistent but there is no time to do better.
	"""
	def __init__(self, c_lib):
		self.c_lib = c_lib
	
	def compute(self, x, y):
		if self.c_lib:
			return pylcs.get_lcs(x, y)
		else:
			m = len(X)
			n = len(Y)
			L = [[0 for x in range(n + 1)] for x in range(m + 1)]
			
			# Following steps build L[m+1][n+1] in bottom up fashion. Note
			# that L[i][j] contains length of LCS of X[0..i-1] and Y[0..j-1]
			for i in range(m + 1):
				for j in range(n + 1):
					if i == 0 or j == 0:
						L[i][j] = 0
					elif X[i - 1] == Y[j - 1]:
						L[i][j] = L[i - 1][j - 1] + 1
					else:
						L[i][j] = max(L[i - 1][j], L[i][j - 1])
			
			# Following code is used to print LCS
			index = L[m][n]
			
			# Create a character array to store the lcs string
			lcs = [""] * (index + 1)
			lcs[index] = ""
			
			# Start from the right-most-bottom-most corner and
			# one by one store characters in lcs[]
			i = m
			j = n
			while i > 0 and j > 0:
				
				# If current character in X[] and Y are same, then
				# current character is part of LCS
				if X[i - 1] == Y[j - 1]:
					lcs[index - 1] = X[i - 1]
					i -= 1
					j -= 1
					index -= 1
				
				# If not same, then find the larger of two and
				# go in the direction of larger value
				elif L[i - 1][j] > L[i][j - 1]:
					i -= 1
				else:
					j -= 1
			return lcs
	
	def compute_n_lcs(self, list_of_vect):
		lcs_result = self.compute(list_of_vect[0], list_of_vect[1])
		for arg in list_of_vect[2:]:
			lcs_result = self.compute(lcs_result, arg)
		return lcs_result


if __name__ == "__main__":
	# Driver program
	# FIXME: (not urgent) test not working
	X = "AAAAAABC"
	Y = "AAAAAADC"
	Z = "EEEEEEEFC"
	
	m = len(X)
	n = len(Y)
	o = len(Z)
	i = lcs(X, Y)
	print(lcs(i, Z))
	print(n_lcs([X, Y, Z]))
