import numpy as np
from scapy.all import *
from scapy.layers.inet import IP, TCP

from Experiments.exp16_visualisation.segmentation_utils import relative_time
from ip_from_malware import ip_from_process_name
from ip_from_pcap import ip_from_packets

load_layer("tls")
COMPACT = True

# Load pcap
packets = rdpcap("./trickbot1_1/capture.pcap")

# Computer IP is common IP of all IP packets
MY_IP = ip_from_packets(packets)
# Filter list, IPs from the malware
IPs = ip_from_process_name(malware_name="malware.exe", path="./trickbot1_1/")

print(MY_IP, IPs)


def is_not_ack(tcp_segment):
	# Size 0 and ACK Flag (0x010)
	return not (tcp_segment[TCP].flags == 0x10 and (
			isinstance(tcp_segment[TCP].payload, packet.NoPayload) or isinstance(tcp_segment[TCP].payload,
			                                                                     packet.Padding)))


def is_tcp(segment):
	return TCP in segment


def get_correct_handshake(pck_list):
	return_list = []
	if len(pck_list) < 3:
		return return_list
	
	for i in range(2, len(pck_list)):
		if pck_list[i - 2][TCP].flags == 0x2 and pck_list[i - 1][TCP].flags == 0x12 and pck_list[i][
			TCP].flags == 0x10:
			handshake_time_interval = [relative_time(pck_list[i - 2].time * 1000000),
			                           relative_time(pck_list[i].time * 1000000)]
			return_list.append(["HANDSHAKE", [i - 2, i], handshake_time_interval])
	return return_list


def get_failed_handshake(pck_list: List[Packet]) -> List:
	return_list = []
	first_i = -1
	in_progress = 0
	for i in range(len(pck_list)):
		if pck_list[i][TCP].flags == 0x2:  # SYN (step 1)
			if not in_progress:
				in_progress = 1
				first_i = i
			elif in_progress:  # Two consecutive connection requests
				handshake_time_interval = [relative_time(
					pck_list[first_i].time * 1000000), relative_time(pck_list[i].time * 1000000)]
				return_list.append(
					["HANDSHAKE_FAILED", [first_i, i], handshake_time_interval])
				first_i = i
		elif pck_list[i][TCP].flags == 0x14:  # RESET-ACK (denied)
			if in_progress:
				handshake_time_interval = [relative_time(
					pck_list[first_i].time * 1000000), relative_time(pck_list[i].time * 1000000)]
				return_list.append(
					["HANDSHAKE_FAILED", [first_i, i], handshake_time_interval])
				in_progress = 0
		elif pck_list[i][TCP].flags == 0x12 or pck_list[i][TCP].flags == 0x11:  # SYN/ACK or SYN/FIN (why ? dont know)
			in_progress = 0
		"""else:
			if in_progress:
				return_list.append(["HANDSHAKE_FAILED", [first_i, i-1]])
				in_progress = 0"""
	if in_progress:  # End of flow
		handshake_time_interval = [relative_time(pck_list[first_i].time * 1000000),
		                           relative_time(pck_list[len(pck_list) - 1].time * 1000000)]
		return_list.append(
			["HANDSHAKE_FAILED", [first_i, len(pck_list) - 1], handshake_time_interval])
	return return_list


print(is_tcp(packets[0]), is_not_ack(packets[0]))

new_packets = list(filter(is_not_ack, filter(is_tcp, packets)))

pktdump = PcapWriter("banana.pcap", append=True, sync=True)
for pck in new_packets:
	pktdump.write(pck)
pktdump.close()


### Traffic record to flows

ip2flow = {}  # ip -> index in group_of_packets
flows = []  # list of flows (packet lists), each sublist correspond to an IP address and a port
flows_first_packet_index = []  # list of packet offsets (nb of packet, not really time)

# Put each packet which appears on the IPs list (generated thanks to netstat) in the correct flow, in flows
for packet_index, packet in enumerate(packets):
	# IPs contains the adresses extracted from netflow, if empty take all
	if len(IPs) == 0 or (len(IPs) != 0 and (packet[IP].src in IPs or packet[IP].dst in IPs)):
		server_IP = [packet[IP].src, packet[IP].dst]
		server_IP.remove(MY_IP)
		server_sock1, server_sock2 = (server_IP[0], packet[TCP].sport, packet[TCP].dport), (server_IP[0], packet[TCP].dport, packet[TCP].sport)
		if server_sock1 in ip2flow or server_sock2:
			flows[ip2flow[server_sock1]].append(packet)
		elif server_sock2 in ip2flow:
			flows[ip2flow[server_sock2]].append(packet)
		else:
			ip2flow[server_sock1] = len(flows)  # Number of flows = next index in list
			flows.append([packet])
			flows_first_packet_index.append(packet_index)
	
segmented_flows = []
# For each flow, segment it
for flow_index, flow in enumerate(flows):
	# Get the segmentation into flows
	segmentation = _segment(flow)
	# list of [type, nb of packet interval, time interval, (size)]
	segmented_flows.append(segmentation)

