import numpy as np
from itertools import groupby
from scapy.all import *
from scapy.layers.inet import IP, TCP
from scapy.packet import NoPayload, Padding
from Experiments.exp16_visualisation.segmentation_utils import relative_time
from ip_from_malware import ip_from_process_name
from ip_from_pcap import ip_from_packets

load_layer("tls")
COMPACT = True

# Load pcap
packets = rdpcap("./trickbot1_1/capture.pcap")

# Computer IP is common IP of all IP packets
MY_IP = ip_from_packets(packets)
# Filter list, IPs from the malware
IPs = ip_from_process_name(malware_name="malware.exe", path="./trickbot1_1/")

print(MY_IP, IPs)
_tls_handshake_type = {'hello_request': 0, 'client_hello': 1, 'server_hello': 2, 'hello_verify_request': 3,
                       'session_ticket': 4, 'hello_retry_request': 6, 'encrypted_extensions': 8, 'certificate': 11,
                       'server_key_exchange': 12, 'certificate_request': 13, 'server_hello_done': 14,
                       'certificate_verify': 15, 'client_key_exchange': 16, 'finished': 20, 'certificate_url': 21,
                       'certificate_status': 22, 'supplemental_data': 23, 'key_update': 24}

_tls_version_options = {"sslv2": 0x0002,
                        "sslv3": 0x0300,
                        "tls1": 0x0301,
                        "tls10": 0x0301,
                        "tls11": 0x0302,
                        "tls12": 0x0303,
                        "tls13-d18": 0x7f12,
                        "tls13-d19": 0x7f13,
                        "tls13": 0x0304}

_tls_vers_dict = inv_map = {v: k for k, v in _tls_version_options.items()}


def is_not_ack(tcp_segment):
	# Size 0 and ACK Flag (0x010)
	return not (tcp_segment[TCP].flags == 0x10 and (
			isinstance(tcp_segment[TCP].payload, NoPayload) or isinstance(tcp_segment[TCP].payload, Padding)))


def is_tcp(segment):
	return TCP in segment


def get_correct_handshake(pck_list):
	return_list = []
	if len(pck_list) < 3:
		return return_list
	
	for i in range(2, len(pck_list)):
		if pck_list[i - 2][TCP].flags == 0x2 and pck_list[i - 1][TCP].flags == 0x12 and pck_list[i][
			TCP].flags == 0x10:
			handshake_time_interval = [relative_time(pck_list[i - 2].time * 1000000),
			                           relative_time(pck_list[i].time * 1000000)]
			return_list.append(["HANDSHAKE", [i - 2, i], handshake_time_interval])
	return return_list


def get_failed_handshake(pck_list: List[Packet]) -> List:
	return_list = []
	first_i = -1
	in_progress = 0
	for i in range(len(pck_list)):
		if pck_list[i][TCP].flags == 0x2:  # SYN (step 1)
			if not in_progress:
				in_progress = 1
				first_i = i
			elif in_progress:  # Two consecutive connection requests
				handshake_time_interval = [relative_time(
					pck_list[first_i].time * 1000000), relative_time(pck_list[i - 1].time * 1000000)]
				return_list.append(
					["HANDSHAKE_FAILED", [first_i, i - 1], handshake_time_interval])
				first_i = i
		elif pck_list[i][TCP].flags == 0x14:  # RESET-ACK (denied)
			if in_progress:
				handshake_time_interval = [relative_time(
					pck_list[first_i].time * 1000000), relative_time(pck_list[i].time * 1000000)]
				return_list.append(
					["HANDSHAKE_FAILED", [first_i, i], handshake_time_interval])
				in_progress = 0
		elif pck_list[i][TCP].flags == 0x12 or pck_list[i][TCP].flags == 0x11:  # SYN/ACK or SYN/FIN (why ? dont know)
			in_progress = 0
		"""else:
			if in_progress:
				return_list.append(["HANDSHAKE_FAILED", [first_i, i-1]])
				in_progress = 0"""
	if in_progress:  # End of flow
		handshake_time_interval = [relative_time(pck_list[first_i].time * 1000000),
		                           relative_time(pck_list[len(pck_list) - 1].time * 1000000)]
		return_list.append(
			["HANDSHAKE_FAILED", [first_i, len(pck_list) - 1], handshake_time_interval])
	return return_list


new_packets = list(filter(is_tcp, packets))

pktdump = PcapWriter("banana.pcap", append=True, sync=True)
for pck in new_packets:
	pktdump.write(pck)
pktdump.close()

### Traffic record to flows

ip2flow = {}  # ip -> index in group_of_packets
flows = []  # list of flows (packet lists), each sublist correspond to an IP address and a port
flows_first_packet_index = []  # list of packet offsets (nb of packet, not really time)

# Put each packet which appears on the IPs list (generated thanks to netstat) in the correct flow, in flows
for packet_index, packet in enumerate(new_packets):
	# IPs contains the adresses extracted from netflow, if empty take all
	if len(IPs) == 0 or (len(IPs) != 0 and (packet[IP].src in IPs or packet[IP].dst in IPs)):
		server_IP = [packet[IP].src, packet[IP].dst]
		server_IP.remove(MY_IP)
		server_sock1, server_sock2 = (server_IP[0], packet[TCP].sport, packet[TCP].dport), (
			server_IP[0], packet[TCP].dport, packet[TCP].sport)
		if server_sock1 in ip2flow:
			flows[ip2flow[server_sock1]].append(packet)
		elif server_sock2 in ip2flow:
			flows[ip2flow[server_sock2]].append(packet)
		else:
			ip2flow[server_sock1] = len(flows)  # Number of flows = next index in list
			flows.append([packet])
			flows_first_packet_index.append(packet_index)


def get_correct_fin(pck_list, last_handshake_packet):
	return_list = []
	for i in range(last_handshake_packet + 1 + 3, len(pck_list)):
		if pck_list[i - 3][TCP].flags == 0x11 and pck_list[i - 2][TCP].flags == 0x10 and pck_list[i - 1][
			TCP].flags == 0x11 and pck_list[i][TCP].flags == 0x10:
			time = [relative_time(
				pck_list[i - 3].time * 1000000), relative_time(pck_list[i].time * 1000000)]
			return_list.append(["TERM", [i - 3, i], time])
	return return_list


def get_reset_fin(pck_list, last_handshake_packet):
	return_list = []
	for i in range(last_handshake_packet + 1, len(pck_list)):
		if pck_list[i][TCP].flags == 0x04 or pck_list[i][TCP].flags == 0x14:
			time = relative_time(pck_list[i].time * 1000000)
			return_list.append(["TERM_RST", [i, i], [time, time]])
	return return_list


def get_fin(pck_list, last_handshake_packet):
	fin = get_correct_fin(pck_list, last_handshake_packet) + get_reset_fin(pck_list, last_handshake_packet)
	return fin


def get_handshake(pck_list):
	handshake = get_correct_handshake(pck_list)
	f_handshake = get_failed_handshake(pck_list)
	
	# If both, check if failed before handshake (sanity)
	if len(handshake) and len(f_handshake):
		if not handshake[0][2][0] > f_handshake[-1][2][1]:
			raise RuntimeWarning("Wtf")
	
	return f_handshake + handshake


def get_packets_stats(list_packets):
	pass


def get_tls_handshake(flow_to_extract, last_i_tcp_handshake):
	# TLS packet with handshake type collected
	tls_handshake_packets = []
	tls_handshake_packets_index = []
	tls_handshake_type = []
	tls_handshake_version = []
	
	for i, pack in enumerate(flow_to_extract):
		if TLS in pack and pack[TLS].type == 22:  # Handshake type
			tls_handshake_packets_index.append(i)
			tls_handshake_packets.append(pack)
			# Collect msg type
			msg_type_list = []
			for message in pack[TLS].msg:  # Can contain msg and row in same time
				if hasattr(message, "msgtype"):
					msg_type_list.append(message.msgtype)
			if len(msg_type_list) != 1:
				raise RuntimeWarning("SSL packet contains more than one message")
			tls_handshake_type.append(msg_type_list[0])
			# Collect tls versions
			tls_handshake_version.append(pack[TLS].version)
		else:  # Sometimes TLS not recognized by scapy ...
			# Simply match the bytes
			if hasattr(pack[TCP], "load") and pack[TCP].load[0] == 0x16 and pack[TCP].load[
				1] == 0x03:  # Major always 0x03
				tls_handshake_packets_index.append(i)
				tls_handshake_packets.append(pack)
				tls_handshake_type.append(int(pack[TCP].load[5]))
				tls_handshake_version.append(struct.unpack(">H", pack[TCP].load[1:3])[0])
	
	# If no TLS handshake ...
	if len(tls_handshake_packets) == 0:
		return []
	
	# Determine if it is a failed handshake or not: failed if only client hello and no server answer
	failed = all(p == 1 for p in tls_handshake_type)
	packet_interval = [last_i_tcp_handshake + 1, last_i_tcp_handshake + 1 + tls_handshake_packets_index[-1]]
	time_interval = [tls_handshake_packets[0].time, tls_handshake_packets[-1].time]
	tls_version = tls_handshake_version[-1]

	packet_list = flow_to_extract[0: tls_handshake_packets_index[-1] + 1]
	stats = get_packets_stats(packet_list)
	
	if failed:
		return ["TLS_HANDSHAKE_FAILED", packet_interval, time_interval, tls_version]
	else:
		return ["TLS_HANDSHAKE", packet_interval, time_interval, tls_version]




def segment_flow(unsegmented_flow):
	return_list = []

	handshakes = get_handshake(unsegmented_flow)
	
	# Sanity check
	if len(handshakes) == 0:  # If no (failed) handshake
		print("no handshake")
		return
	
	fins = get_fin(unsegmented_flow, handshakes[-1][1][1])
	
	# Sanity check
	nb_hand = len([a for a in handshakes if a[0] == "HANDSHAKE"])
	if not len(fins) <= nb_hand <= len(fins) + 1:
		return
	
	if nb_hand != 1 and len(fins) > 1:
		return
	
	# Segment for each handshake
	for handshake_i, handshake in enumerate(handshakes):
		h_type, h_pack, h_time = handshake[0], handshake[1], handshake[2]
		if h_type == "HANDSHAKE_FAILED":
			return_list.append([h_type, h_pack, h_time, -1])
		elif h_type == "HANDSHAKE":
			return_list.append([h_type, h_pack, h_time, -1])
			last_handshake_packet_index = h_pack[1]
			# Check if there is an end for this handshake
			if len(fins) == 0:
				flow_to_seg = unsegmented_flow[last_handshake_packet_index + 1:]
			elif len(fins) == 1:
				flow_to_seg = unsegmented_flow[last_handshake_packet_index + 1: fins[0][1][0]]
			# Get TLS handshake with information
			tls_handshake = get_tls_handshake(flow_to_seg, last_handshake_packet_index)
			return_list += [tls_handshake]
			
			is_tls_handshake = (len(tls_handshake) != 0)
			
			if is_tls_handshake and len(fins) == 0:
				last_handshake_packet_index = tls_handshake[1][1]
				flow_to_seg = unsegmented_flow[tls_handshake[1][1] + 1:]
			elif is_tls_handshake and len(fins) == 1:
				last_handshake_packet_index = tls_handshake[1][1]
				flow_to_seg = unsegmented_flow[tls_handshake[1][1] + 1: fins[0][1][0]]
			
			# Segment the body of the flow (without handshake and end)
			no_ack_bitmap = [is_not_ack(pack) for pack in flow_to_seg]
			
			previous_packet_type = "ACK"
			segmented_list = []
			
			print(flow_to_seg[0][IP].sport, flow_to_seg[0][IP].dport)
			
			# Classify each packet
			for i, pack in enumerate(flow_to_seg):
				not_ack = no_ack_bitmap[i]
				# Determine the type of the packet
				if not_ack and is_tls_handshake:
					is_incoming = pack[IP].dst == MY_IP
					is_tls = pack.haslayer(TLS) or (
							hasattr(pack[TCP], "load") and pack[TCP].load[0] in [0x16, 0x14, 0x15, 0x17, 0x18] and
							pack[TCP].load[1] == 0x03)
					
					# Get TLS param
					if is_tls and pack.haslayer(TLS):
						version = pack[TLS].version
						tls_param = [version]
					elif is_tls and not pack.haslayer(TLS):
						version = struct.unpack(">H", pack[TCP].load[1:3])[0]
						tls_param = [version]
					else:
						tls_param = [-1]
					
					# Get packet size
					size = pack[IP].len - 40
					
					if is_incoming:
						packet_type = "INCOMING_TLS"
					else:
						packet_type = "OUTGOING_TLS"
					
					seq_info = [packet_type, last_handshake_packet_index + 1 + i, pack.time, size]
					seq_info += tls_param
					segmented_list.append(seq_info)
					previous_packet_type = packet_type
				elif not_ack and not is_tls_handshake:
					is_incoming = pack[IP].dst == MY_IP
					# Get packet size
					size = pack[IP].len - 40
					
					if is_incoming:
						packet_type = "INCOMING"
					else:
						packet_type = "OUTGOING"
					
					seq_info = [packet_type, last_handshake_packet_index + 1 + i, pack.time, size]
					segmented_list.append(seq_info)
					previous_packet_type = packet_type
				else:
					to_add = []
					if len(segmented_list) and len(segmented_list[-1]) > 4:
						to_add = segmented_list[-1][4:]
					
					seq_info = [previous_packet_type, last_handshake_packet_index + 1 + i, pack.time, 0] + to_add
					segmented_list.append(seq_info)
			
			# Handle ack after handshake
			for i, elem in enumerate(segmented_list[:-1]):
				if elem[0] == "ACK":
					segmented_list[i][0] = segmented_list[i + 1][0]
					if len(segmented_list[i + 1]) > 4:
						segmented_list[i] += segmented_list[i + 1][4:]
			
			# Consolidate the packets into general actions
			consolidate_list = []
			idx = 0
			for key, sub in groupby(segmented_list, key=lambda a: a[0]):
				list_of_cons = np.array(list(sub))
				
				c_type = list_of_cons[0][0]
				c_pack_inter = [list_of_cons[0][1], list_of_cons[-1][1]]
				c_time_inter = [list_of_cons[0][2], list_of_cons[-1][2]]
				if len(list_of_cons[0]) > 3:
					c_size = np.sum(list_of_cons[:, 3])
				else:
					c_size = -1
				if len(list_of_cons[0]) > 4:
					c_tls_v = list(set(list_of_cons[:, 4]))
					if -1 in c_tls_v: c_tls_v.remove(-1)
					c_tls_v = c_tls_v[0] if len(c_tls_v) != 0 else -1
				else:
					c_tls_v = -1
				ele = len(list_of_cons)
				consolidate_list.append([c_type, c_pack_inter, c_time_inter, c_size, c_tls_v])
				idx += ele
			return_list += consolidate_list
	return return_list


segmented_flows = []
# For each flow, segment it
for flow_index, flow in enumerate(flows):
	# Get the segmentation into flows
	segmentation = segment_flow(flow)
	print(segmentation)
	# list of [type, nb of packet interval, time interval, (size)]
	segmented_flows.append(segmentation)


# TLS Handshake detection
def detect_tls_handshake(pck_list, last_handshake_packet):
	tls_handshake_index_list = []
	tls_handshake_packet_list = []
	for i in range(last_handshake_packet + 1, len(pck_list)):
		if (TLS in pck_list[i] and pck_list[i][TLS].type == 0x16) or (
				hasattr(pck_list[i][TCP], "load") and pck_list[i][TCP].load[0:2] == b"\x16\x03"):
			tls_handshake_index_list.append(i)
			tls_handshake_packet_list.append(pck_list[i])
	
	def test_client_hello_only(to_test):
		if not to_test.haslayer(TLS):
			if TCP in to_test and hasattr(to_test[TCP], "load") and to_test[TCP].load[0:2] in [b"\x16\x03",
			                                                                                   b"\x14\x03"] and \
					to_test[TCP].load[5] == b"\x01":
				return 1
			return 0
		# print(str(to_test[TLS].msg))
		if hasattr(to_test[TLS], "msg") and to_test[TLS].msg[0] and hasattr(to_test[TLS].msg[0], "msgtype") and \
				to_test[TLS].msg[0].msgtype == 0x01:
			return 1
		return 0
	
	def get_tls_version_list(list_of_packets):
		type_version_list = []
		for packet in list_of_packets:
			if packet.haslayer(TLS):
				type_version_list.append(packet[TLS].version)
			elif TCP in packet and hasattr(packet[TCP], "load") and packet[TCP].load[0] in [b"\x16", b"\x14"] and \
					packet[TCP].load[5] == b"\x01":
				type_version_list.append(int(packet[TCP].load[1:3], 16))
		# TODO: untested branch
		return type_version_list
	
	if len(tls_handshake_index_list) > 0:
		time = [relative_time(pck_list[tls_handshake_index_list[0]].time * 1000000),
		        relative_time(pck_list[tls_handshake_index_list[-1]].time * 1000000)]
		only_hello_test = list(map(test_client_hello_only, tls_handshake_packet_list))
		
		#  Get TLS version
		tls_version_list = get_tls_version_list(tls_handshake_packet_list)
		if tls_version_list:
			tls_version = int(tls_version_list[-1])
		else:
			tls_version = -1
		
		# If the sequence of TLS packets contain only a client hello, then it failed (no server response)
		if np.count_nonzero(only_hello_test) == len(only_hello_test):
			return [["Failed_TLS_handshake", [tls_handshake_index_list[0], tls_handshake_index_list[-1]], time,
			         tls_version]]
		# Is considered succesful a TLS handshake with a server response (here implemented as other types than client hello)
		
		# +1 because ack packet just after, was accounted wrongly as OUT
		return [
			["TLS_handshake", [tls_handshake_index_list[0], tls_handshake_index_list[-1] + 1], time, tls_version]]
	return []
