from itertools import groupby

import numpy as np
from scapy.all import *
from scapy.layers.inet import IP, TCP
from scapy.layers.tls.record import TLS
from scapy.packet import NoPayload, Padding
import os

from Experiments.exp16_visualisation.segmentation_utils import relative_time
from ip_from_malware import ip_from_process_name
from ip_from_pcap import ip_from_packets

load_layer("tls")
COMPACT = True

_tls_handshake_type = {'hello_request': 0, 'client_hello': 1, 'server_hello': 2, 'hello_verify_request': 3,
                       'session_ticket': 4, 'hello_retry_request': 6, 'encrypted_extensions': 8, 'certificate': 11,
                       'server_key_exchange': 12, 'certificate_request': 13, 'server_hello_done': 14,
                       'certificate_verify': 15, 'client_key_exchange': 16, 'finished': 20, 'certificate_url': 21,
                       'certificate_status': 22, 'supplemental_data': 23, 'key_update': 24}

_tls_version_options = {"sslv2": 0x0002,
                        "sslv3": 0x0300,
                        "tls1": 0x0301,
                        "tls10": 0x0301,
                        "tls11": 0x0302,
                        "tls12": 0x0303,
                        "tls13-d18": 0x7f12,
                        "tls13-d19": 0x7f13,
                        "tls13": 0x0304}

color_dictionary = {'HANDSHAKE': 'xkcd:goldenrod',
                    "HANDSHAKE_FAILED": 'xkcd:purple',
                    'TERM': 'xkcd:maroon',
                    'TERM_RST': 'xkcd:red',
                    "INCOMING": 'xkcd:green',
                    'INCOMING_TLS': 'xkcd:chartreuse',
                    'OUTGOING': 'xkcd:blue',
                    'OUTGOING_TLS': 'xkcd:sky blue',
                    'TLS_HANDSHAKE': 'tab:brown',
                    'TLS_HANDSHAKE_FAILED': 'xkcd:crimson'}

_tls_vers_dict = {v: k for k, v in _tls_version_options.items()}


def get_packets_stats(list_packets):
	time_list = [pack.time for pack in list_packets]

	if len(time_list) != 1:
		inter_packet_time_list = [t - s for s, t in zip(time_list, time_list[1:])]
	else:
		inter_packet_time_list = [-1]
	inter_avg = float(np.mean(inter_packet_time_list))
	inter_std = float(np.std(inter_packet_time_list))
	inter_max = float(np.max(inter_packet_time_list))
	inter_min = float(np.min(inter_packet_time_list))

	length_list = [pack[IP].len - 40 for pack in list_packets]
	length_avg = float(np.mean(length_list))
	length_std = float(np.std(length_list))
	length_max = float(np.max(length_list))
	length_min = float(np.min(length_list))

	return [inter_avg, inter_std, inter_min, inter_max, length_avg, length_std, length_min, length_max]


def is_not_ack(tcp_segment):
	# Size 0 and ACK Flag (0x010)
	return not (tcp_segment[TCP].flags == 0x10 and (
			isinstance(tcp_segment[TCP].payload, NoPayload) or isinstance(tcp_segment[TCP].payload, Padding)))


def is_tcp(segment):
	return TCP in segment


def get_correct_handshake(pck_list):
	return_list = []
	if len(pck_list) < 3:
		return return_list

	for i in range(2, len(pck_list)):
		if pck_list[i - 2][TCP].flags == 0x2 and pck_list[i - 1][TCP].flags == 0x12 and pck_list[i][
			TCP].flags == 0x10:
			handshake_time_interval = [relative_time(pck_list[i - 2].time * 1000000),
			                           relative_time(pck_list[i].time * 1000000)]
			stats = get_packets_stats(pck_list[i - 2: i + 1])
			return_list.append(["HANDSHAKE", [i - 2, i], handshake_time_interval] + stats)
	return return_list


def get_failed_handshake(pck_list: List[Packet]) -> List:
	return_list = []
	first_i = -1
	in_progress = 0
	for i in range(len(pck_list)):
		if pck_list[i][TCP].flags == 0x2:  # SYN (step 1)
			if not in_progress:
				in_progress = 1
				first_i = i
			elif in_progress:  # Two consecutive connection requests
				handshake_time_interval = [relative_time(
					pck_list[first_i].time * 1000000), relative_time(pck_list[i - 1].time * 1000000)]
				stats = get_packets_stats(pck_list[first_i: i])
				return_list.append(
					["HANDSHAKE_FAILED", [first_i, i - 1], handshake_time_interval] + stats)
				first_i = i
		elif pck_list[i][TCP].flags == 0x14:  # RESET-ACK (denied)
			if in_progress:
				handshake_time_interval = [relative_time(
					pck_list[first_i].time * 1000000), relative_time(pck_list[i].time * 1000000)]
				stats = get_packets_stats(pck_list[first_i: i + 1])
				return_list.append(
					["HANDSHAKE_FAILED", [first_i, i], handshake_time_interval] + stats)
				in_progress = 0
		elif pck_list[i][TCP].flags == 0x12 or pck_list[i][TCP].flags == 0x11:  # SYN/ACK or SYN/FIN (why ? dont know)
			in_progress = 0
		"""else:
			if in_progress:
				return_list.append(["HANDSHAKE_FAILED", [first_i, i-1]])
				in_progress = 0"""
	if in_progress:  # End of flow
		handshake_time_interval = [relative_time(pck_list[first_i].time * 1000000),
		                           relative_time(pck_list[len(pck_list) - 1].time * 1000000)]
		stats = get_packets_stats(pck_list[first_i: len(pck_list)])
		return_list.append(
			["HANDSHAKE_FAILED", [first_i, len(pck_list) - 1], handshake_time_interval] + stats)
	return return_list


def get_correct_fin(pck_list, last_handshake_packet):
	return_list = []
	for i in range(last_handshake_packet + 1 + 3, len(pck_list)):
		if pck_list[i - 3][TCP].flags == 0x11 and pck_list[i - 2][TCP].flags == 0x10 and pck_list[i - 1][
			TCP].flags == 0x11 and pck_list[i][TCP].flags == 0x10:
			time = [relative_time(
				pck_list[i - 3].time * 1000000), relative_time(pck_list[i].time * 1000000)]
			stats = get_packets_stats(pck_list[i - 3: i + 1])
			return_list.append(["TERM", [i - 3, i], time] + stats)
	if len(return_list) == 0:
		# Packers may be interleaved with ack...
		for i in range(last_handshake_packet + 1, len(pck_list)):
			if pck_list[i][TCP].flags == 0x11 and len(pck_list) - i < 7:
				time = [relative_time(
					pck_list[i].time * 1000000), relative_time(pck_list[-1].time * 1000000)]
				stats = get_packets_stats(pck_list[i:])
				return_list.append(["TERM", [i, len(pck_list) - 1], time] + stats)
				break
	return return_list


def get_reset_fin(pck_list, last_handshake_packet):
	return_list = []
	for i in range(last_handshake_packet + 1, len(pck_list)):
		if pck_list[i][TCP].flags == 0x04 or pck_list[i][TCP].flags == 0x14:
			time = relative_time(pck_list[i].time * 1000000)
			stats = get_packets_stats(pck_list[i: i + 1])
			return_list.append(["TERM_RST", [i, i], [time, time]] + stats)
	return return_list


def get_fin(pck_list, last_handshake_packet):
	fin = get_correct_fin(pck_list, last_handshake_packet)
	if len(fin) == 0:
		fin = get_reset_fin(pck_list, last_handshake_packet)
	return fin


def get_handshake(pck_list):
	handshake = get_correct_handshake(pck_list)
	f_handshake = get_failed_handshake(pck_list)

	# If both, check if failed before handshake (sanity)
	if len(handshake) and len(f_handshake):
		if not handshake[0][2][0] > f_handshake[-1][2][1]:
			raise RuntimeWarning("Wtf")

	return f_handshake + handshake


def get_tls_handshake(flow_to_extract, last_i_tcp_handshake):
	# TLS packet with handshake type collected
	tls_handshake_packets = []
	tls_handshake_packets_index = []
	tls_handshake_type = []
	tls_handshake_version = []

	for i, pack in enumerate(flow_to_extract):
		if TLS in pack and pack[TLS].type == 22:  # Handshake type
			tls_handshake_packets_index.append(i)
			tls_handshake_packets.append(pack)
			# Collect msg type
			msg_type_list = []
			for message in pack[TLS].msg:  # Can contain msg and row in same time
				if hasattr(message, "msgtype"):
					msg_type_list.append(message.msgtype)
			if len(msg_type_list) != 1:
				raise RuntimeWarning("SSL packet contains more than one message")
			tls_handshake_type.append(msg_type_list[0])
			# Collect tls versions
			tls_handshake_version.append(pack[TLS].version)
		else:  # Sometimes TLS not recognized by scapy ...
			# Simply match the bytes
			if hasattr(pack[TCP], "load") and pack[TCP].load[0] == 0x16 and pack[TCP].load[
				1] == 0x03:  # Major always 0x03
				tls_handshake_packets_index.append(i)
				tls_handshake_packets.append(pack)
				tls_handshake_type.append(int(pack[TCP].load[5]))
				tls_handshake_version.append(struct.unpack(">H", pack[TCP].load[1:3])[0])

	# If no TLS handshake ...
	if len(tls_handshake_packets) == 0:
		return []

	# Determine if it is a failed handshake or not: failed if only client hello and no server answer
	failed = all(p == 1 for p in tls_handshake_type)
	packet_interval = [last_i_tcp_handshake + 1, last_i_tcp_handshake + 1 + tls_handshake_packets_index[-1]]
	time_interval = [relative_time(tls_handshake_packets[0].time * 1000000),
	                 relative_time(tls_handshake_packets[-1].time * 1000000)]
	tls_version = tls_handshake_version[-1]

	packet_list = flow_to_extract[0: tls_handshake_packets_index[-1] + 1]
	stats = get_packets_stats(packet_list)

	# TODO: add more features : msg types
	if failed:
		return ["TLS_HANDSHAKE_FAILED", packet_interval, time_interval] + stats + [tls_version] + [-1]
	else:
		return ["TLS_HANDSHAKE", packet_interval, time_interval] + stats + [tls_version] + [-1]


def segment_flow(unsegmented_flow, MY_IP):
	return_list = []

	handshakes = get_handshake(unsegmented_flow)

	# Sanity check
	if len(handshakes) == 0:  # If no (failed) handshake
		print("no handshake")
		return []

	fins = get_fin(unsegmented_flow, handshakes[-1][1][1])

	# Sanity check
	nb_hand = len([a for a in handshakes if a[0] == "HANDSHAKE"])
	if not len(fins) <= nb_hand <= len(fins) + 1:
		print("Number of handshakes/fins inconsistent", len(fins), nb_hand)
		return []

	if nb_hand != 1 and len(fins) > 1:
		print("Number of fins inconsistent")
		return

	# Segment for each handshake
	for handshake_i, handshake in enumerate(handshakes):
		h_type, h_pack, h_time = handshake[0], handshake[1], handshake[2]
		if h_type == "HANDSHAKE_FAILED":
			return_list.append(handshake + [-1, -1])
		elif h_type == "HANDSHAKE":
			return_list.append(handshake + [-1, -1])
			last_handshake_packet_index = h_pack[1]
			# Check if there is an end for this handshake
			if len(fins) == 0:
				flow_to_seg = unsegmented_flow[last_handshake_packet_index + 1:]
			elif len(fins) == 1:
				flow_to_seg = unsegmented_flow[last_handshake_packet_index + 1: fins[0][1][0]]
			# Get TLS handshake with information
			tls_handshake = get_tls_handshake(flow_to_seg, last_handshake_packet_index)
			is_tls_handshake = (len(tls_handshake) != 0)

			if is_tls_handshake:
				return_list += [tls_handshake]

			if is_tls_handshake and len(fins) == 0:
				last_handshake_packet_index = tls_handshake[1][1]
				flow_to_seg = unsegmented_flow[tls_handshake[1][1] + 1:]
			elif is_tls_handshake and len(fins) == 1:
				last_handshake_packet_index = tls_handshake[1][1]
				flow_to_seg = unsegmented_flow[tls_handshake[1][1] + 1: fins[0][1][0]]

			# Segment the body of the flow (without handshake and end)
			no_ack_bitmap = [is_not_ack(pack) for pack in flow_to_seg]

			previous_packet_type = "ACK"
			segmented_list = []

			# print(flow_to_seg[0][IP].sport, flow_to_seg[0][IP].dport)

			# Classify each packet
			for i, pack in enumerate(flow_to_seg):
				not_ack = no_ack_bitmap[i]
				# Determine the type of the packet
				if not_ack and is_tls_handshake:
					is_incoming = pack[IP].dst == MY_IP
					is_tls = pack.haslayer(TLS) or (
							hasattr(pack[TCP], "load") and pack[TCP].load[0] in [0x16, 0x14, 0x15, 0x17, 0x18] and
							pack[TCP].load[1] == 0x03)

					# Get TLS param
					if is_tls and pack.haslayer(TLS):
						version = pack[TLS].version
						tls_param = [version]
					elif is_tls and not pack.haslayer(TLS):
						version = struct.unpack(">H", pack[TCP].load[1:3])[0]
						tls_param = [version]
					else:
						tls_param = [-1]

					# Get packet size
					size = pack[IP].len - 40

					if is_incoming:
						packet_type = "INCOMING_TLS"
					else:
						packet_type = "OUTGOING_TLS"

					seq_info = [packet_type, last_handshake_packet_index + 1 + i, pack.time, size]
					seq_info += tls_param
					segmented_list.append(seq_info)
					previous_packet_type = packet_type
				elif not_ack and not is_tls_handshake:
					is_incoming = pack[IP].dst == MY_IP
					# Get packet size
					size = pack[IP].len - 40

					if is_incoming:
						packet_type = "INCOMING"
					else:
						packet_type = "OUTGOING"

					seq_info = [packet_type, last_handshake_packet_index + 1 + i, pack.time, size]
					segmented_list.append(seq_info)
					previous_packet_type = packet_type
				else:
					to_add = []
					if len(segmented_list) and len(segmented_list[-1]) > 4:
						to_add = segmented_list[-1][4:]

					seq_info = [previous_packet_type, last_handshake_packet_index + 1 + i, pack.time, 0] + to_add
					segmented_list.append(seq_info)

			# Handle ack after handshake
			for i, elem in enumerate(segmented_list[:-1]):
				if elem[0] == "ACK":
					segmented_list[i][0] = segmented_list[i + 1][0]
					if len(segmented_list[i + 1]) > 4:
						segmented_list[i] += segmented_list[i + 1][4:]

			# Consolidate the packets into general actions
			consolidate_list = []
			idx = 0
			for key, sub in groupby(segmented_list, key=lambda a: a[0]):
				list_of_cons = np.array(list(sub))

				c_type = list_of_cons[0][0]
				c_pack_inter = [list_of_cons[0][1], list_of_cons[-1][1]]
				c_time_inter = [relative_time(list_of_cons[0][2] * 1000000),
				                relative_time(list_of_cons[-1][2] * 1000000)]
				# Test working ? Stats after so must be ok
				if len(list_of_cons[0]) > 3:
					c_size = np.sum(list_of_cons[:, 3])
				else:
					c_size = -1
				if len(list_of_cons[0]) > 4:
					c_tls_v = list(set(list_of_cons[:, 4]))
					if -1 in c_tls_v: c_tls_v.remove(-1)
					c_tls_v = c_tls_v[0] if len(c_tls_v) != 0 else -1
				else:
					c_tls_v = -1
				ele = len(list_of_cons)

				packets_to_stat = unsegmented_flow[c_pack_inter[0]: c_pack_inter[1] + 1]
				stats = get_packets_stats(packets_to_stat)
				consolidate_list.append([c_type, c_pack_inter, c_time_inter] + stats + [c_tls_v, c_size])
				idx += ele
			return_list += consolidate_list
	if len(fins) == 1:
		fin = fins[0] + [-1, -1]
		return_list += [fin]
	return return_list


def get_seg(path, malware_exe="malware.exe"):
	"""
	The function transforms a pcap file into segmented flows (list of segmented flows)
	The general actions have the following format:
	0: type (e.g : TLS_HANDSHAKE)
	1: packet interval (e.g : [5:5])
	2: time interval (e.g : [t1, t2])
	3-10: stats given by get_packets_stats
	11: tls version
	12: group size
	"""
	# Load pcap
	packet_path = os.path.join(path, "capture.pcap")
	packets = rdpcap(packet_path)

	# Computer IP is common IP of all IP packets
	MY_IP = ip_from_packets(packets)
	# Filter list, IPs from the malware
	IPs = ip_from_process_name(malware_name=malware_exe, path=path)

	new_packets = list(filter(is_tcp, packets))

	pktdump = PcapWriter("banana.pcap", append=True, sync=True)
	for pck in new_packets:
		pktdump.write(pck)
	pktdump.close()

	### Traffic record to flows

	ip2flow = {}  # ip -> index in group_of_packets
	flows = []  # list of flows (packet lists), each sublist correspond to an IP address and a port
	flows_first_packet_index = []  # list of packet offsets (nb of packet, not really time)

	# Put each packet which appears on the IPs list (generated thanks to netstat) in the correct flow, in flows
	for packet_index, packet in enumerate(new_packets):
		# IPs contains the adresses extracted from netflow, if empty take all
		if len(IPs) == 0 or (len(IPs) != 0 and (packet[IP].src in IPs or packet[IP].dst in IPs)):
			server_IP = [packet[IP].src, packet[IP].dst]
			server_IP.remove(MY_IP)
			server_sock1, server_sock2 = (server_IP[0], packet[TCP].sport, packet[TCP].dport), (
				server_IP[0], packet[TCP].dport, packet[TCP].sport)
			if server_sock1 in ip2flow:
				flows[ip2flow[server_sock1]].append(packet)
			elif server_sock2 in ip2flow:
				flows[ip2flow[server_sock2]].append(packet)
			else:
				ip2flow[server_sock1] = len(flows)  # Number of flows = next index in list
				flows.append([packet])
				flows_first_packet_index.append(packet_index)

	segmented_flows = []
	# For each flow, segment it
	for flow_index, flow in enumerate(flows):
		# Get the segmentation into flows
		segmentation = segment_flow(flow, MY_IP)
		if len(segmentation) != 0:  # FIXME:skipping one empty list shift the dictionary, problem only with visualization
			for elem in segmentation:
				assert (len(elem) == 13)
			# list of [type, nb of packet interval, time interval, (size)]
			segmented_flows.append(segmentation)
	return segmented_flows, ip2flow


def visualize_segmentation(segmented_flows, ip2flow_dict):
	# Initialize plot
	fig, ax = plt.subplots(figsize=(20, 10))
	# Map index in group_of_packets to IP
	inv_map = {v: k for k, v in ip2flow_dict.items()}
	# Help to construct the sequential plot
	last_indexes = [0]

	# For each group of packet, draw in the plot with the corresponding colors
	for flow_i, flow in enumerate(segmented_flows):
		for action_i, action in enumerate(flow):
			action_color = color_dictionary.get(action[0], 'tab:blue')
			# 0 is time_offset
			ax.broken_barh([(0 + int(action[1][0]), 1 + int(action[1][1]) - int(action[1][0]))], (10 * flow_i, 9),
			               facecolors=action_color, label=action[0])
			ax.grid(True)

	handles, labels = plt.gca().get_legend_handles_labels()
	by_label = dict(zip(labels, handles))
	plt.legend(by_label.values(), by_label.keys(), loc=4)

	ax.set_yticks([5 + 10 * i for i in range(len(segmented_flows))])
	ax.set_yticklabels([inv_map[i] for i in range(len(segmented_flows))])
	plt.xlabel('Time (arbitrary)')
	plt.ylabel('TCP Socket')
	plt.title("TCP Segmentation visualization")
	plt.show()


if __name__ == "__main__":
	flows, ip2flow = get_seg("./trickbot1_1/")
	visualize_segmentation(flows, ip2flow)
