#pylint: disable=too-many-arguments

from segmentation import get_segmentation
from api_extraction import get_malware_traces, time_map
import matplotlib.pyplot as plt
import numpy as np
import matplotlib.patches as mpatches

color_dictionary = {
    'HANDSHAKE': 'xkcd:goldenrod',
    'TERM': 'xkcd:maroon',
    "IN":  'xkcd:green',
    'IN_TLS': 'xkcd:chartreuse',
    'OUT': 'xkcd:blue',
    'OUT_TLS': 'xkcd:sky blue',
    'TERM_RST': 'xkcd:red',
    "HANDSHAKE_FAILED": 'xkcd:red',
    'TLS_handshake': 'tab:brown',
    'Failed_TLS_handshake': 'xkcd:crimson'
}

# TODO: properly handle this
MALWARE_NAME = "2020-09-30-Trickbot-EXE.exe"
PATH = "./trickbot_1/"

TIME_DELAY_ALLOWED = 45

def visualise():
    # TODO: better visualisation of API calls
    # TODO: variable are no longer explicit
    # TODO: missing doc

    # Get the segmentation in flows
    segmentations, packet_offsets = get_segmentation(path=PATH)
    # Initialize plot
    _, ax = plt.subplots(figsize=(20, 10))
    # Vectorize the plot with those variables
    plot_xranges = []
    plot_facecolors = []
    plot_labels = []

    for j in range(len(segmentations)):
        segmentation = segmentations[j]
        # For each group of packet, draw in the plot with the corresponding colors
        time_offset = packet_offsets[j]
        # list of [type, nb of packet interval, time interval, (size)]
        # print(segmentation)
        # For each identified type, draw it with correct color
        for i in range(len(segmentation)):
            type_color = color_dictionary.get(segmentation[i][0], 'tab:blue')
            # ['HANDSHAKE', [0, 2], [1612708961378936, 1612708961422139]],
            plot_xranges.append((time_offset + int(segmentation[i][1][0]), 1+int(segmentation[i][1][1]) - int(segmentation[i][1][0]) + 1))
            plot_facecolors.append(type_color)
            plot_labels.append(segmentation[i][0])
            # Graph in packets for each segm
            # ax.broken_barh([ (time_offset + int(segmentation[i][1][0]), 1+int(segmentation[i][1][1]) - int(segmentation[i][1][0]))], (0, 2), facecolors=type_color, label=segmentation[i][0])
            # ax.broken_barh([(segmentation[i][2][0], segmentation[i][2][1]-segmentation[i][2][0])], (0, 2), facecolors=type_color, label=segmentation[i][0])
            ax.grid(True)
    # Draw segmentation
    ax.broken_barh(plot_xranges, (0, 2), facecolors=plot_facecolors, label=plot_labels)
    
    # Draw legend
    patch_list = []
    for key in list(set(plot_labels)):
            data_key = mpatches.Patch(color=color_dictionary[key], label=key)
            patch_list.append(data_key)
    plt.legend(handles=patch_list, loc=4)

    # Variable that helps vectorizing the draw of arrows
    x_axis_positions = []
    annotations = []
    # Get the API traces
    traces_df_list = get_malware_traces(path=PATH)
    for trace_df in traces_df_list:
        # For each trace, get the lines and plot them
        trace_np = trace_df.to_numpy()
        for line in trace_np:
            _, api_name, _, time_in_int = line
            for i in range(len(segmentations)):
                segmentation = segmentations[i]
                time_offset = packet_offsets[i]
                for j in range(len(segmentation)):
                    if len(segmentation[j]) == 3:
                        _, pck_int, time_int = segmentation[j]
                    else: # Size is present for some kind of type
                        _, pck_int, time_int, _ = segmentation[j]
                    mapping = time_map(time_int[0], time_int[1], pck_int[0] + time_offset, pck_int[1] + time_offset, time_in_int)
                    if mapping:
                        x_axis_positions.append(mapping)
                        annotations.append(api_name)

    # Vectorize the draw of arrows, very quick
    ax.quiver(x_axis_positions, [2 for _ in range(len(x_axis_positions))], 0, 1, scale=20.0)
    # ax.quiverkey(quiv, x_axis_positions, [5 for _ in range(len(x_axis_positions))], )
    plt.xlabel('Time')
    plt.ylabel('TCP Socket')
    plt.ylim((-10, 10))
    plt.title("TCP Segmentation visualization")
    plt.show()


if __name__ == '__main__':
    visualise()
