#pylint: disable=too-many-arguments

from segmentation import get_segmentation
from api_extraction import get_malware_traces
import matplotlib.pyplot as plt

color_dictionary = {
    'HANDSHAKE': 'xkcd:goldenrod',
    'TERM': 'xkcd:maroon',
    "IN":  'xkcd:green',
    'IN_TLS': 'xkcd:chartreuse',
    'OUT': 'xkcd:blue',
    'OUT_TLS': 'xkcd:sky blue',
    'TERM_RST': 'xkcd:red',
    "HANDSHAKE_FAILED": 'xkcd:red',
    'TLS_handshake': 'tab:brown',
    'Failed_TLS_handshake': 'xkcd:crimson'
}

MALWARE_NAME = "20-09-08-Trickbot-EXE-gtag-ono72.exe"
TIME_DELAY_ALLOWED = 20


def time_map(time_a, time_b, packet_a, packet_b, time_c, window_tolerance=TIME_DELAY_ALLOWED):
    """
    Map an API time into a packet number.
    This function was done in order to have a nice visualisation.
    The window tolereance is used to capture nearby calls
            =========     |
            ta      tb    tc=>pc
            pa      pb

    Args:
        time_a (float): time of the begining of the flow (in seconds since epoch, time.time())
        time_b (float): time of the ending of the flow
        packet_a (int): packet number of the begining of the flow
        packet_b (int): packet number of the ending of the flow
        time_c (float): time of the api call
        window_tolerance (int): time shift in second in which api calls are still considered to belong to the flow

    Returns:
        int: packet number, return None if the mapping fails
    """

    # Check if inside flow
    if time_a <= time_c <= time_b: # Chain comparaison
        return packet_a + (time_c - time_a) * (packet_b - packet_a) / (time_b - time_a)
    # Check if in the window border (simple)
    if time_a - window_tolerance <= time_c:
        return packet_a
    if time_c <= time_b + window_tolerance:
        return packet_b
    # Outside
    return None


def visualise():
    # TODO: better visualisation
    # TODO: display flows the old way, map around/into it the api calls
    # Get the segmentation in flows
    segmentations, time_offsets, packet_offsets = get_segmentation()

    # Initialize plot
    fig, ax = plt.subplots(figsize=(20, 10))
    # Help to construct the sequential plot
    last_indexes = [0]
    # Help to draw the API calls
    packet_intervals = []
    for j in range(len(segmentations)):
        segmentation = segmentations[j]
        # For each group of packet, draw in the plot with the corresponding colors
        time_offset = time_offsets[j]
        # list of [type, nb of packet interval, time interval, (size)]
        # print(segmentation)
        # For each identified type, draw it with correct color
        for i in range(len(segmentation)):
            packet_intervals.append(segmentation[i][1])
            type_color = color_dictionary.get(segmentation[i][0], 'tab:blue')
            # ['HANDSHAKE', [0, 2], [1612708961378936, 1612708961422139]],
            ax.broken_barh([ (time_offset + int(segmentation[i][1][0]), 1+int(segmentation[i][1][1]) - int(segmentation[i][1][0]))], (0, 2), facecolors=type_color, label=segmentation[i][0])
            #ax.broken_barh([(segmentation[i][2][0], segmentation[i][2][1]-segmentation[i][2][0])], (0, 2), facecolors=type_color, label=segmentation[i][0])
            ax.grid(True)

        handles, labels = plt.gca().get_legend_handles_labels()
        by_label = dict(zip(labels, handles))
        plt.legend(by_label.values(), by_label.keys(), loc=4)

    # Get the API traces
    traces_df_list = get_malware_traces()
    print(packet_intervals)
    for trace_df in traces_df_list:
        # For each trace, get the lines and plot them
        trace_np = trace_df.to_numpy()
        for line in trace_np:
            time, api_name, category, time_int = line
            # Draw arrows for each calls
            style = dict(size=10, color='gray', rotation='vertical')
            """ax.arrow(time_int, 2, 0, 3)
            ax.text(time_int, 5, api_name, **style)"""


    plt.xlabel('Time')
    plt.ylabel('TCP Socket')
    plt.ylim((-10, 10))
    plt.title("TCP Segmentation visualization")
    plt.show()


if __name__ == '__main__':
    visualise()
