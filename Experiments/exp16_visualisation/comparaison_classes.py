import numpy as np
from fastdtw import fastdtw
import pylcs # I rewrote this library /!\
import matplotlib.pyplot as plt

# This is making noise ?
# TODO: need to prove this is useless considering LCS
# blacklist_filter = np.array(["GetProcAddress", "RegCloseKey", 'GetCurrentProcess', 'OpenProcessToken', 'CryptCreateHash', 'WSARecv'])
blacklist_filter = np.array([])


class Singleton(type):
	_instances = {}
	
	def __call__(cls, *args, **kwargs):
		if cls not in cls._instances:
			cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
		return cls._instances[cls]


class CachedCustomLCS(metaclass=Singleton):
	# TODO: C Wrapper
	def __init__(self, c_lib=True):
		self.cache = {}
		self.operations = 0
		self.misses = 0
		if c_lib:
			self.c_lib = True
		else:
			self.c_lib = False

	
	def compute(self, x, y):
		self.operations += 1
		if blacklist_filter.shape[0] != 0:
			x, y = np.setdiff1d(x, blacklist_filter), np.setdiff1d(y, blacklist_filter)
		x, y = tuple(x), tuple(y)
		if len(x) == 0 or len(y) == 0:
			return 0
		result = self.cache.get(frozenset([x, y]))
		
		if not result:
			self.misses += 1
			old_x, old_y = x, y
			x, y = np.array(x), np.array(y)
			if self.c_lib:
				result = pylcs.test(x, y)
			else:
				result = self.custom_lcs(x, y)
			self.cache[frozenset([old_x, old_y])] = result
		return result
	
	@staticmethod
	def custom_lcs(x, y):
		dp_table = np.zeros((len(x) + 1, len(y) + 1))
		for i in range(1, len(x) + 1):
			for j in range(1, len(y) + 1):
				if x[i - 1][0] == y[j - 1][0]:  # Types
					final_score = 1
					size1, size2 = x[i - 1][2], y[j - 1][2]
					tls1, tls2 = x[i - 1][1], y[j - 1][1]
					is_size = size1 != -2 and size2 != -2
					is_tls = (tls1 is not None) and (tls2 is not None)
					list_scores = [1]
					if is_size and size1 != 0 and size2 != 0:
						size1, size2 = np.max([size1, size2]), np.min([size1, size2])
						list_scores.append(1 - (size1 - size2) / size1)
					elif is_size and (size1 == 0 ^ size2 == 0):
						list_scores.append(1)
					if is_tls:
						list_scores.append(0.5 + 0.5 * (tls1 == tls2))
					if len(list_scores) > 0:
						final_score = np.sum(list_scores) / len(list_scores)
					# print(f"Comparaison bbetween { x[i - 1][0] } and {y[j - 1][0]} : {final_score}")
					# print(x[i - 1], y[j - 1])
					dp_table[i - 1, j - 1] = final_score + dp_table[i - 2, j - 2]
				else:
					dp_table[i - 1, j - 1] = max(dp_table[i - 1, j - 2], dp_table[i - 2, j - 1])
		return dp_table[len(x) - 1, len(y) - 1] / max(len(x), len(y))
	
	def print_stat(self):
		if self.operations:
			print(f"Custom LCS --- {self.operations} ops, {(self.misses / self.operations):.2f} missrate")
			


class CachedLCS(metaclass=Singleton):
	def __init__(self, c_lib=True):
		self.cache = {}
		self.operations = 0
		self.misses = 0
		if c_lib:
			self.seq2txt = {}
			self.current = 1
			self.c_lib = True
		else:
			self.c_lib = False
	
	def compute(self, x, y):
		self.operations += 1
		if blacklist_filter.shape[0] != 0:
			x, y = np.setdiff1d(x, blacklist_filter), np.setdiff1d(y, blacklist_filter)
		x, y = tuple(x), tuple(y)
		if len(x) == 0 or len(y) == 0:
			return 0
		result = self.cache.get(frozenset([x, y]))
		
		# Transform the numpy ndarray list into tuple to make it hashable
		# Keys from dict need to be hashable
		# The frozenset is hashable
		if not result:
			self.misses += 1
			if self.c_lib:
				old_x, old_y = x, y
				x = self.transform2text(x)
				y = self.transform2text(y)
				result = pylcs.lcs2(x, y) / min(len(x), len(y))
				self.cache[frozenset([old_x, old_y])] = result
			else:
				result = self.lcs_dp(x, y)
				self.cache[frozenset([x, y])] = result
		return result
	
	def transform2text(self, x):
		str_return = ""
		for item in x:
			character = self.seq2txt.get(item)
			if character is None:
				character = chr(self.current)
				self.seq2txt[item] = chr(self.current)
				self.current += 1
			str_return += character
		return str_return
	
	@staticmethod
	def lcs_dp(x, y):
		dp_table = np.zeros((len(x) + 1, len(y) + 1))
		for i in range(1, len(x) + 1):
			for j in range(1, len(y) + 1):
				if x[i - 1] == y[j - 1]:
					dp_table[i - 1, j - 1] = 1 + dp_table[i - 2, j - 2]
				else:
					dp_table[i - 1, j - 1] = max(dp_table[i - 1, j - 2], dp_table[i - 2, j - 1])
		return dp_table[len(x) - 1, len(y) - 1] / max(len(x), len(y))
	
	def print_stat(self):
		if self.operations:
			print(f"LCS --- {self.operations} ops, {(self.misses / self.operations):.2f} missrate")


class CachedDTW(metaclass=Singleton):
	def __init__(self):
		self.cache = {}
		self.operations = 0
		self.misses = 0
		self.scores = []
	
	def compute(self, x, y):
		result = self.cache.get(frozenset([x, y]))
		self.operations += 1
		if not result:
			self.misses += 1
			result = self.distance(x, y)
			self.cache[frozenset([x, y])] = result
		self.scores.append(result)
		return result
	
	def show_score_histo(self):
		plt.figure()
		plt.hist(self.scores, bins=20)
		plt.title("Histogram of DTW scores")
		plt.show()
	
	@staticmethod
	def custom_dist(a, b):
		return a != b
	
	@staticmethod
	def distance(a, b):
		l1, l2 = len(a), len(b)
		a = [ord(i) for i in a]
		b = [ord(i) for i in b]
		
		dtw_distance, _ = fastdtw(list(a), list(b), dist=CachedDTW.custom_dist)
		sim = (max(l1, l2) - dtw_distance) / max(l1, l2)
		return sim
	
	def print_stat(self):
		if self.operations:
			print(f"DTW --- {self.operations} ops, {(self.misses / self.operations):.2f} missrate")


if __name__ == '__main__':
	a = CachedLCS()
