import numpy as np
from fastdtw import fastdtw
import pylcs


class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


class CachedLCS(metaclass=Singleton):
    def __init__(self, c_lib=True):
        self.cache = {}
        self.operations = 0
        self.misses = 0
        if c_lib:
            self.seq2txt = {}
            self.current = 1
            self.c_lib = True
        else:
            self.c_lib = False

    def compute(self, x, y):
        self.operations += 1
        x, y = tuple(x), tuple(y)
        result = self.cache.get(frozenset([x, y]))

        # Transform the numpy ndarray list into tuple to make it hashable
        # Keys from dict need to be hashable
        # The frozenset is hashable
        if not result:
            self.misses += 1
            if self.c_lib:
                old_x, old_y = x, y
                x = self.transform2text(x)
                y = self.transform2text(y)
                result = pylcs.lcs(x, y) / min(len(x), len(y))
                self.cache[frozenset([old_x, old_y])] = result
            else:
                result = self.lcs_dp(x, y)
                self.cache[frozenset([x, y])] = result
        return result

    def transform2text(self, x):
        str_return = ""
        for item in x:
            character = self.seq2txt.get(item)
            if character is None:
                character = chr(self.current)
                self.seq2txt[item] = chr(self.current)
                self.current += 1
            str_return += character
        return str_return

    @staticmethod
    def lcs_dp(x, y):
        dp_table = np.zeros((len(x) + 1, len(y) + 1))
        for i in range(1, len(x) + 1):
            for j in range(1, len(y) + 1):
                if x[i - 1] == y[j - 1]:
                    dp_table[i - 1, j - 1] = 1 + dp_table[i - 2, j - 2]
                else:
                    dp_table[i - 1, j - 1] = max(dp_table[i - 1, j - 2], dp_table[i - 2, j - 1])
        return dp_table[len(x) - 1, len(y) - 1] / min(len(x), len(y))

    def print_stat(self):
        print("LCS --- ", self.operations, " ops, ", (self.misses/self.operations), " missrate")


class CachedDTW(metaclass=Singleton):
    def __init__(self):
        self.cache = {}
        self.operations = 0
        self.misses = 0

    def compute(self, x, y):
        result = self.cache.get(frozenset([x, y]))
        self.operations += 1
        if not result:
            self.misses += 1
            result = self.distance(x, y)
            self.cache[frozenset([x, y])] = result
        return result

    @staticmethod
    def custom_dist(a, b):
        return a != b

    def distance(self, a, b):
        l1, l2 = len(a), len(b)
        a = [ord(i) for i in a]
        b = [ord(i) for i in b]

        dtw_distance, _ = fastdtw(list(a), list(b), dist=CachedDTW.custom_dist)
        sim = (max(l1, l2) - dtw_distance) / max(l1, l2)
        return sim

if __name__ == '__main__':
    a = CachedLCS()