import numpy as np
from fastdtw import fastdtw


class Singleton(type):
    _instances = {}

    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]


class CachedLCS(metaclass=Singleton):
    def __init__(self):
        self.cache = {}

    def compute(self, x, y):
        """result = self.cache.get(frozenset([x, y]))
        if not result:
            result = self.lcs_dp(x, y)
            self.cache[frozenset([x, y])] = result"""
        result = self.lcs_dp(x, y)
        return result

    def lcs_dp(self, x, y):
        # create a table for dynamic programming of size
        # (len(x)+1)x(len(y)+1)
        dp_table = np.zeros((len(x) + 1, len(y) + 1))
        # solve the problem in a bottom up manner
        for i in range(1, len(x) + 1):
            for j in range(1, len(y) + 1):
                if x[i - 1] == y[j - 1]:
                    dp_table[i - 1, j - 1] = 1 + dp_table[i - 2, j - 2]
                else:
                    dp_table[i - 1, j - 1] = max(dp_table[i - 1, j - 2], dp_table[i - 2, j - 1])
        return dp_table[len(x) - 1, len(y) - 1] / min(len(x), len(y))


class CachedDTW(metaclass=Singleton):
    def __init__(self):
        super().__init__()
        self.cache = {}

    def compute(self, x, y):
        result = self.cache.get(frozenset([x, y]))
        if not result:
            result = self.distance(x, y)
            self.cache[frozenset([x, y])] = result
        return result

    def custom_dist(self, a, b):
        return a != b

    def distance(self, a, b):
        l1, l2 = len(a), len(b)
        a = [ord(i) for i in a]
        b = [ord(i) for i in b]

        dtw_distance, _ = fastdtw(list(a), list(b), dist=self.custom_dist)
        sim = (max(l1, l2) - dtw_distance) / max(l1, l2)
        return sim
