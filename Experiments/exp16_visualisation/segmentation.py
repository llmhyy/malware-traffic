# pylint: disable=E0602
# pylint: disable=W0614

import logging
from scapy.all import *
from scapy.layers.inet import IP, TCP
import matplotlib.pyplot as plt
import numpy as np

from ip_from_pcap import ip_from_packets
from ip_from_malware import ip_from_pid, ip_from_process_name

load_layer("tls")
packets = rdpcap('capture.pcap')
# Computer IP is common IP of all IP packets
MY_IP = ip_from_packets(packets)
# Filter list, IPs from the malware
IPs = ip_from_process_name()
# More compact/readable visualisation
COMPACT = False


def _segment(pck_list):
    # Get time origin
    time_origin = pck_list[0].time * 1000000

    def relative_time(timestamp):
        return int(timestamp)
        # return int(timestamp-time_origin)

    # Handshake detection
    def detect_correct_handshake(pck_list):
        return_list = []
        for i in range(2, len(pck_list)):
            if pck_list[i-2][TCP].flags == 0x2 and pck_list[i-1][TCP].flags == 0x12 and pck_list[i][TCP].flags == 0x10:
                time = [relative_time(
                    pck_list[i-2].time * 1000000), relative_time(pck_list[i].time * 1000000)]
                return_list.append(["HANDSHAKE", [i-2, i], time])
        return return_list

    # Failed handshake detection
    def detect_failed_handshake(pck_list):
        return_list = []
        first_i = -1
        in_progress = 0
        for i in range(len(pck_list)):
            if pck_list[i][TCP].flags == 0x2:
                if not in_progress:
                    in_progress = 1
                    first_i = i
            elif pck_list[i][TCP].flags == 0x14:
                if in_progress:
                    time = [relative_time(
                        pck_list[first_i].time * 1000000), relative_time(pck_list[i].time * 1000000)]
                    return_list.append(
                        ["HANDSHAKE_FAILED", [first_i, i], time])
                    in_progress = 0
            elif pck_list[i][TCP].flags == 0x12 or pck_list[i][TCP].flags == 0x11:
                in_progress = 0
            """else:
                if in_progress:
                    return_list.append(["HANDSHAKE_FAILED", [first_i, i-1]])
                    in_progress = 0"""
        if in_progress:
            time = [relative_time(pck_list[first_i].time * 1000000),
                    relative_time(pck_list[len(pck_list)-1].time * 1000000)]
            return_list.append(
                ["HANDSHAKE_FAILED", [first_i, len(pck_list)-1], time])
        return return_list

    def handshake_wrapper(pck_list):
        handshake = detect_correct_handshake(pck_list)
        if handshake == []:
            handshake = detect_failed_handshake(pck_list)
        return handshake

    handshake = handshake_wrapper(pck_list)
    last_handshake_packet = handshake[-1][1][-1] if handshake else -1
    logging.debug(handshake, last_handshake_packet)

    # TLS Handshake detection
    def detect_tls_handshake(pck_list, last_handshake_packet):
        tls_handshake_index_list = []
        tls_handshake_packet_list = []
        for i in range(last_handshake_packet+1, len(pck_list)):
            if (TLS in pck_list[i] and pck_list[i][TLS].type == 0x16) or (hasattr(pck_list[i][TCP], "load") and pck_list[i][TCP].load[0:2] == b"\x16\x03"):
                tls_handshake_index_list.append(i)
                tls_handshake_packet_list.append(pck_list[i])

        def test_client_hello(to_test):
            if not to_test.haslayer(TLS):
                if TCP in to_test and hasattr(to_test[TCP], "load") and to_test[TCP].load[0:2] == b"\x16\x03" and to_test[TCP].load[5] == b"\x01":
                    return 1
                return 0
            if to_test[TLS].msg[0].msgtype == 0x01:
                return 1
            return 0

        if len(tls_handshake_index_list) > 0:
            time = [relative_time(pck_list[tls_handshake_index_list[0]].time * 1000000),
                    relative_time(pck_list[tls_handshake_index_list[-1]].time * 1000000)]
            only_hello_test = list(
                map(test_client_hello, tls_handshake_packet_list))
            if np.count_nonzero(only_hello_test) == len(only_hello_test):
                return [["Failed_TLS_handshake", [tls_handshake_index_list[0], tls_handshake_index_list[-1]], time]]
            return [["TLS_handshake", [tls_handshake_index_list[0], tls_handshake_index_list[-1]], time]]
        return []

    tls_handshake = detect_tls_handshake(pck_list, last_handshake_packet)
    if tls_handshake != []:
        last_handshake_packet = tls_handshake[0][1][-1]
        handshake.append(tls_handshake[0])

    # End detection
    def detect_fin(pck_list, last_handshake_packet):
        return_list = []
        for i in range(last_handshake_packet+1+3, len(pck_list)):
            if pck_list[i-3][TCP].flags == 0x11 and pck_list[i-2][TCP].flags == 0x10 and pck_list[i-1][TCP].flags == 0x11 and pck_list[i][TCP].flags == 0x10:
                time = [relative_time(
                    pck_list[i-3].time * 1000000), relative_time(pck_list[i].time * 1000000)]
                return_list.append(["TERM", [i-3, i], time])
        return return_list

    # Rst End detection
    def detect_rst_fin(pck_list, last_handshake_packet):
        return_list = []
        for i in range(last_handshake_packet+1, len(pck_list)):
            if pck_list[i][TCP].flags == 0x04 or pck_list[i][TCP].flags == 0x14:
                time = relative_time(pck_list[i].time * 1000000)
                return_list.append(["TERM_RST", [i, i], [time, time]])
        return return_list

    def end_wrapper(pck_list, last_handshake_packet):
        fin = detect_fin(pck_list, last_handshake_packet)
        if fin == []:
            fin = detect_rst_fin(pck_list, last_handshake_packet)
        return fin

    fin = end_wrapper(pck_list, last_handshake_packet)
    first_end_packet = fin[0][1][0] if fin else None
    logging.debug(fin)

    # Detect flow
    def detect_flow(pck_list, last_handshake_packet, first_end_packet=None):
        return_list = []
        if first_end_packet is None:
            first_end_packet = len(pck_list)
        else:
            first_end_packet += 1
        if last_handshake_packet is None:
            last_handshake_packet = -1
        if last_handshake_packet == first_end_packet - 1:
            return []

        def detect_tls(pck):
            if pck.haslayer(TLS):
                return 1
            if hasattr(pck[TCP], "load") and pck[TCP].load[1:3] == b"\x03\x01":
                return 1
            return 0

        ini_seq = pck_list[last_handshake_packet+1][TCP].seq
        ini_ack = pck_list[last_handshake_packet+1][TCP].ack
        flow_len = pck_list[last_handshake_packet+1][IP].len - 40
        last_i = last_handshake_packet+1
        ip_adds = [pck_list[last_handshake_packet+1][IP].src]
        is_tls = detect_tls(pck_list[last_handshake_packet+1])
        ini_time = pck_list[last_handshake_packet+1].time

        for i in range(last_handshake_packet+2, first_end_packet):
            # Skip the reception ack / Len 0 TCP packets
            if pck_list[i][IP].len == 40 and pck_list[i][TCP].flags == 0x10 and pck_list[i][TCP].seq == ini_ack:
                continue

            # Segment TCP inbound/outbound :
            if (detect_tls(pck_list[i]) != is_tls) and (ini_ack == pck_list[i][TCP].ack and pck_list[i][TCP].flags in [0x10, 0x18]):
                direction = "IN" + is_tls * "_TLS"
                if list(set(ip_adds))[0] == MY_IP:
                    direction = "OUT" + is_tls * "_TLS"
                time = [relative_time(ini_time * 1000000),
                        relative_time(pck_list[i-1].time * 1000000)]
                return_list.append([direction, [last_i, i-1], time, flow_len])

                # Set new flow
                ip_adds = [pck_list[i][IP].src]
                flow_len = max(pck_list[i][IP].len - 40, 0)
                last_i = i
                is_tls = detect_tls(pck_list[i])
                ini_time = pck_list[i].time
            elif (ini_ack == pck_list[i][TCP].ack and pck_list[i][TCP].flags in [0x10, 0x18]):
                # same out/inbound = same ack
                ip_adds.append(pck_list[i][IP].src)
                flow_len += max(pck_list[i][IP].len - 40, 0)
            else:
                # This packet is from a new ~flow

                # Close flow and register
                ini_ack = pck_list[i][TCP].ack
                direction = "IN" + is_tls * "_TLS"
                if list(set(ip_adds))[0] == MY_IP:
                    direction = "OUT" + is_tls * "_TLS"
                time = [relative_time(ini_time * 1000000),
                        relative_time(pck_list[i-1].time * 1000000)]
                return_list.append([direction, [last_i, i-1], time, flow_len])

                # Set new flow
                ip_adds = [pck_list[i][IP].src]
                flow_len = max(pck_list[i][IP].len - 40, 0)
                last_i = i
                is_tls = detect_tls(pck_list[i])
                ini_time = pck_list[i].time

        return return_list

    flow = detect_flow(pck_list, last_handshake_packet, first_end_packet)
    logging.debug([*handshake, *flow, *fin])
    return [*handshake, *flow, *fin]


def get_segmentation(packet_name='capture.pcap', pid=0):
    """
    Get the segmentation in flows of a pcap file.

    Args:
        packet_name (str, optional): path of the pcap file. Defaults to 'capture.pcap'.
        pid (int, optional): pid of the malware, todo is to get it automaticaly. Defaults to 0.

    Returns:
        list: list of flows
        list: packet_offsets
    """

    # Load pcap
    packets = rdpcap('capture.pcap')
    # Computer IP is common IP of all IP packets
    MY_IP = ip_from_packets(packets)
    # Filter list, IPs from the malware
    IPs = ip_from_process_name()

    dictionary = {}  # ip -> index in group_of_packets
    group_of_packets = []  # list of list of packets, each sublist correspond to an IP address
    packet_offsets = []  # list of packet offsets (nb of packet, not really time)

    # Put each packet which appears on the IPs list (generated thanks to netstat) in the correct list, in group_of_packets
    for packet_index in range(len(packets)):
        packet = packets[packet_index]
        if TCP in packet and IP in packet:
            if len(IPs) == 0 or (len(IPs) != 0 and (packet[IP].src in IPs or packet[IP].dst in IPs)):

                server_IP = [packet[IP].src, packet[IP].dst]
                server_IP.remove(MY_IP)
                server_IP1, server_IP2 = (server_IP[0], packet[TCP].sport, packet[TCP].dport), (
                    server_IP[0], packet[TCP].dport, packet[TCP].sport)

                if server_IP1 in dictionary:
                    group_of_packets[dictionary[server_IP1]].append(packet)
                elif server_IP2 in dictionary:
                    group_of_packets[dictionary[server_IP2]].append(packet)
                else:
                    dictionary[server_IP1] = len(group_of_packets)
                    group_of_packets.append([packet])
                    packet_offsets.append(packet_index)

    # List to return
    list_of_segmentations = []
    # For each group of packet, draw in the plot with the corresponding colors
    for j in range(len(group_of_packets)):
        pck_list = group_of_packets[j]
        # Get the segmentation into flows
        segmentation = _segment(pck_list)
        # list of [type, nb of packet interval, time interval, (size)]
        list_of_segmentations.append(segmentation)

    return list_of_segmentations, packet_offsets


def get_visualisation():

    dictionary = {}  # ip -> index in group_of_packets
    group_of_packets = []  # list of list of packets, each sublist correspond to an IP address
    time_offsets = []  # list of packet offsets (nb of packet, not really time)

    # Put each packet which appears on the IPs list (generated thanks to netstat) in the correct list, in group_of_packets
    for packet_index in range(len(packets)):
        packet = packets[packet_index]
        if TCP in packet and IP in packet:
            if len(IPs) == 0 or (len(IPs) != 0 and (packet[IP].src in IPs or packet[IP].dst in IPs)):

                server_IP = [packet[IP].src, packet[IP].dst]
                server_IP.remove(MY_IP)
                server_IP1, server_IP2 = (server_IP[0], packet[TCP].sport, packet[TCP].dport), (
                    server_IP[0], packet[TCP].dport, packet[TCP].sport)

                if server_IP1 in dictionary:
                    group_of_packets[dictionary[server_IP1]].append(packet)
                elif server_IP2 in dictionary:
                    group_of_packets[dictionary[server_IP2]].append(packet)
                else:
                    dictionary[server_IP1] = len(group_of_packets)
                    group_of_packets.append([packet])
                    time_offsets.append(packet_index)

    # Initialize plot
    fig, ax = plt.subplots(figsize=(20, 10))
    # Map index in group_of_packets to IP
    inv_map = {v: k for k, v in dictionary.items()}
    # Help to construct the sequential plot
    last_indexes = [0]

    # For each group of packet, draw in the plot with the corresponding colors
    for j in range(len(group_of_packets)):
        pck_list = group_of_packets[j]
        time_offset = time_offsets[j]
        # Get the segmentation into flows
        segmentation = _segment(pck_list)
        # list of [type, nb of packet interval, time interval, (size)]
        print(segmentation)

        if COMPACT:  # Delete all the spaces between packets
            time_offset = sum(last_indexes)
            last_indexes.append(segmentation[-1][1][1])

        # For each identified type, draw it with correct color
        for i in range(len(segmentation)):
            color_dictionary = {
                'HANDSHAKE': 'xkcd:goldenrod',
                'TERM': 'xkcd:maroon',
                "IN":  'xkcd:green',
                'IN_TLS': 'xkcd:chartreuse',
                'OUT': 'xkcd:blue',
                'OUT_TLS': 'xkcd:sky blue',
                'TERM_RST': 'xkcd:red',
                "HANDSHAKE_FAILED": 'xkcd:red',
                'TLS_handshake': 'tab:brown',
                'Failed_TLS_handshake': 'xkcd:crimson'
            }

            COLOR = color_dictionary.get(segmentation[i][0], 'tab:blue')
            ax.broken_barh([(time_offset + int(segmentation[i][1][0]), 1+int(segmentation[i][1][1]) -
                             int(segmentation[i][1][0]))], (0, 2), facecolors=COLOR, label=segmentation[i][0])
            # ax.broken_barh([(segmentation[i][2][0], segmentation[i][2][1]-segmentation[i][2][0])], (10*j, 9), facecolors=color, label=segmentation[i][0])

            ax.grid(True)

    handles, labels = plt.gca().get_legend_handles_labels()
    by_label = dict(zip(labels, handles))
    plt.legend(by_label.values(), by_label.keys(), loc=4)

    """ax.set_yticks([5+10*i for i in range(len(group_of_packets))])
    ax.set_yticklabels([inv_map[i] for i in range(len(group_of_packets))])
    """
    """#Color IPs in initial config file
    ini_ips = get_ips()
    for t in ax.yaxis.get_ticklabels():
        check_vector = [ini_ip in t.get_text() for ini_ip in ini_ips]
        if True in check_vector:
            t.set_color('red')
        else:
            t.set_color('green')"""

    plt.xlabel('Time (arbitrary)')
    plt.ylabel('TCP Socket')
    plt.title("TCP Segmentation visualization")
    plt.show()


if __name__ == '__main__':
    get_visualisation()
