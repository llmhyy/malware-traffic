from segmentation import get_segmentation
from api_extraction import get_malware_traces, get_segmented_flow_syscalls
from clustering import cluster_segmented_flow, segmented_to_char
import matplotlib.pyplot as plt
import numpy as np
from fastdtw import fastdtw
from comparaison_classes import CachedLCS, CachedDTW

# TODO: properly handle this
MALWARE_NAME = "malware.exe"
PATH = "./trickbot1_3/"
TIME_DELAY_ALLOWED = 0


def lcs_dp(x, y):
    # create a table for dynamic programming of size
    # (len(x)+1)x(len(y)+1)
    dp_table = np.zeros((len(x) + 1, len(y) + 1))
    # solve the problem in a bottom up manner
    for i in range(1, len(x) + 1):
        for j in range(1, len(y) + 1):
            if x[i - 1] == y[j - 1]:
                dp_table[i - 1, j - 1] = 1 + dp_table[i - 2, j - 2]
            else:
                dp_table[i - 1, j - 1] = max(dp_table[i - 1, j - 2], dp_table[i - 2, j - 1])
    return dp_table[len(x) - 1, len(y) - 1] / min(len(x), len(y))


def intra_cluster_quality_matrix(cluster):
    LCS_engine = CachedLCS()
    n = len(cluster)
    matrix = np.zeros((n, n))
    for i in range(n):
        for j in range(i):
            matrix[i][j] = LCS_engine.compute(cluster[i][:, 1], cluster[j][:, 1])
    print(matrix)
    print("Score=", np.sum(matrix) / (n * (n - 1) / 2))
    return matrix


def custom_dist(a, b):
    return a != b


def inter_cluster_similarity_matrix(cluster1, cluster2):
    DTW_engine = CachedDTW()
    m, n = len(cluster1), len(cluster2)
    matrix = np.zeros((n, n))
    for i in range(m):
        for j in range(n):
            matrix[i][j] = DTW_engine.compute(cluster1[i][:, 1], cluster2[j][:, 1])
    print(matrix)
    print("Score=", np.sum(matrix) / (n * m))
    return matrix


def correlate():
    # Get the segmentation in flows
    segmentations, _ = get_segmentation(path=PATH, malware_process_name=MALWARE_NAME)
    cluster_indexes, nb_class = cluster_segmented_flow(segmentations)
    call_dict = {k: np.empty((0, 4)) for k in range(nb_class)}
    call_dict2 = {k: [] for k in range(nb_class)}
    for i in range(len(segmentations)):
        segmentation = segmentations[i]
        cluster = cluster_indexes[i]
        syscalls = get_segmented_flow_syscalls(segmentation, MALWARE_NAME, path=PATH)
        if syscalls.shape[0]:
            call_dict[cluster] = np.vstack((call_dict[cluster], syscalls))
            call_dict2[cluster].append(syscalls)
    for k, v in call_dict.items():
        sorted_indexes = np.argsort(v[:, -1])
        call_dict[k] = v[sorted_indexes]
        print(k, v.shape)
        intra_cluster_quality_matrix(call_dict2[k])
    # inter_cluster_similarity_matrix(segmented_to_char(segmentations)[cluster_indexes==0], segmented_to_char(segmentations)[cluster_indexes==1])


# TODO: do matrix on this to answer research question 1

if __name__ == "__main__":
    correlate()
