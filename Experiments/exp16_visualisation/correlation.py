from segmentation import get_segmentation
from api_extraction import get_segmented_flow_syscalls
from clustering import cluster_segmented_flow, segmented_to_char
import matplotlib.pyplot as plt
import numpy as np
from comparaison_classes import CachedLCS, CachedDTW
from itertools import product

TIME_DELAY_ALLOWED = 10


def intra_cluster_quality_matrix(cluster):
    # Too heavy to compute
    LCS_engine = CachedLCS()
    n = len(cluster)
    matrix = np.zeros((n, n))
    if n == 0:
        return 0
    for i in range(n):
        for j in range(i):
            matrix[i][j] = LCS_engine.compute(cluster[:, 1], cluster[:, 1])
    # print(matrix)
    return np.sum(matrix) / (n * (n - 1) / 2)


def custom_dist(a, b):
    return a != b


def inter_cluster_similarity_matrix(cluster1, cluster2):
    DTW_engine = CachedDTW()
    m, n = len(cluster1), len(cluster2)
    if m == 0 or n == 0:
        return None
    matrix = np.zeros((m, n))
    for i in range(m):
        for j in range(n):
            matrix[i][j] = DTW_engine.compute(cluster1[i], cluster2[j])
    # print(matrix)
    # return np.max(matrix)
    return np.sum(matrix) / (n * m)


def inter_cluster_intention_matrix(cluster1, cluster2):
    LCS_engine = CachedLCS(c_lib=True)
    m, n = len(cluster1), len(cluster2)
    if m == 0 or n == 0:
        return None
    matrix = np.zeros((m, n))
    for i in range(m):
        for j in range(n):
            matrix[i][j] = LCS_engine.compute(cluster1[i][:, 1], cluster2[j][:, 1])
    # print(matrix)
    return np.sum(matrix) / (n * m)


def get_malware_segmentation_cluster_sequence(path, malware_process_name):
    # Get the segmentation in flows
    segmentations, _ = get_segmentation(path=path, malware_process_name=malware_process_name)
    cluster_indexes, nb_class = cluster_segmented_flow(segmentations, 4)
    call_dict = {k: np.empty((0, 4)) for k in range(nb_class)}
    call_dict2 = {k: [] for k in range(nb_class)}
    for i in range(len(segmentations)):
        segmentation = segmentations[i]
        cluster = cluster_indexes[i]
        syscalls = get_segmented_flow_syscalls(segmentation, malware_process_name, path=path,
                                               time_delay_allowed=TIME_DELAY_ALLOWED)
        if syscalls.shape[0]:
            call_dict[cluster] = np.vstack((call_dict[cluster], syscalls))
            call_dict2[cluster].append(syscalls)
    for k, v in call_dict.items():
        print(f"Cluster {k} : {v.shape}")
        sorted_indexes = np.argsort(v[:, -1])
        call_dict[k] = v[sorted_indexes]
    return segmentations, cluster_indexes, nb_class, call_dict, call_dict2


def correlate():
    segmentations, cluster_indexes, nb_class, call_dict, call_dict2 = get_malware_segmentation_cluster_sequence(
        "trickbot1_1/", "malware.exe")
    # Building final research matrix
    X = []
    Y = []
    for i in range(nb_class):
        for j in range(i):
            intention = inter_cluster_intention_matrix(call_dict2[i], call_dict2[j])
            appearance = inter_cluster_similarity_matrix(
                np.array(segmented_to_char(segmentations)[0])[cluster_indexes == i],
                np.array(segmented_to_char(segmentations)[0])[cluster_indexes == j])
            if intention is None or appearance is None:
                continue
            X.append(appearance)
            Y.append(intention)
    plt.xlabel("Cluster similarity")
    plt.ylabel("API Call Sequence similarity")
    h = plt.hist2d(X, Y, bins=[25, 25], range=[[0, 1], [0, 1]])
    plt.colorbar(h[3])
    plt.plot([0, 1], [0, 1], ls="--", c=".3")
    plt.show()

    # intra_cluster_quality_matrix(call_dict2[k])
    # inter_cluster_similarity_matrix(np.array(segmented_to_char(segmentations)[0])[cluster_indexes == 0],np.array(segmented_to_char(segmentations)[0])[cluster_indexes == 1])
    # inter_cluster_similarity_matrix(np.array(segmented_to_char(segmentations)[0])[cluster_indexes == 0],np.array(segmented_to_char(segmentations)[0])[cluster_indexes == 0])
    # inter_cluster_intention_matrix(call_dict2[0], call_dict2[1])


def correlate2():
    # TODO: take multiple clusters
    segmentations1, cluster_indexes1, nb_class1, call_dict_1, call_dict2_1 = get_malware_segmentation_cluster_sequence(
        "old_data/batch2/trickbot1_2/", "malware.exe")
    segmentations2, cluster_indexes2, nb_class2, call_dict_2, call_dict2_2 = get_malware_segmentation_cluster_sequence(
        "old_data/batch2/trickbot1_3/", "malware.exe")

    # Building final research matrix
    for i in range(nb_class1):
        for j in range(nb_class2):
            intention = inter_cluster_intention_matrix(call_dict2_1[i], call_dict2_2[j])
            appearance = inter_cluster_similarity_matrix(
                np.array(segmented_to_char(segmentations1)[0])[cluster_indexes1 == i],
                np.array(segmented_to_char(segmentations2)[0])[cluster_indexes2 == j])
            if intention is None or appearance is None:
                continue
            X.append(appearance)
            Y.append(intention)
    plt.figure()
    plt.xlabel("Cluster similarity")
    plt.ylabel("API Call Sequence similarity")
    h = plt.hist2d(X, Y, bins=[25, 25], range=[[0, 1], [0, 1]])
    plt.colorbar(h[3])
    plt.plot([0, 1], [0, 1], ls="--", c=".3")
    plt.show()

def correlate3(list_of_paths):
    segmentations_list, cluster_indexes_list, nb_classes_list, call_dict1_list, call_dict2_list = [], [], [], [], []
    X = []
    Y = []
    for path in list_of_paths:
        segmentations1, cluster_indexes1, nb_class1, call_dict_1, call_dict2_1 = get_malware_segmentation_cluster_sequence(path, "malware.exe")
        segmentations_list.append(segmentations1)
        cluster_indexes_list.append(cluster_indexes1)
        nb_classes_list.append(nb_class1)
        call_dict1_list.append(call_dict_1)
        call_dict2_list.append(call_dict2_1)
    for x in range(len(segmentations_list)):
        for y in range(len(segmentations_list)):
            segmentations1, cluster_indexes1, nb_class1, call_dict_1, call_dict2_1 = segmentations_list[x], cluster_indexes_list[x], nb_classes_list[x], call_dict1_list[x], call_dict2_list[x]
            segmentations2, cluster_indexes2, nb_class2, call_dict_2, call_dict2_2 = segmentations_list[y], cluster_indexes_list[y], nb_classes_list[y], call_dict1_list[y], call_dict2_list[y]
            for i in range(nb_class1):
                for j in range(nb_class2):
                    intention = inter_cluster_intention_matrix(call_dict2_1[i], call_dict2_2[j])
                    appearance = inter_cluster_similarity_matrix(
                        np.array(segmented_to_char(segmentations1)[0])[cluster_indexes1 == i],
                        np.array(segmented_to_char(segmentations2)[0])[cluster_indexes2 == j])
                    if intention is None or appearance is None:
                        continue
                    X.append(appearance)
                    Y.append(intention)
    plt.figure()
    plt.xlabel("Cluster similarity")
    plt.ylabel("API Call Sequence similarity")
    h = plt.hist2d(X, Y, bins=[25, 25], range=[[0, 1], [0, 1]])
    plt.colorbar(h[3])
    plt.plot([0, 1], [0, 1], ls="--", c=".3")
    plt.show()

    # Building final research matrix
    X = []
    Y = []
    # TODO: finish

# TODO: do matrix on this to answer research question 1

if __name__ == "__main__":
    correlate3(["old_data/batch2/trickbot1_1/", "old_data/batch2/trickbot1_2/", "old_data/batch2/trickbot1_3/"])
    CachedDTW().show_score_histo()
    print("-------Caching------------------------------")
    CachedLCS().print_stat()
    CachedDTW().print_stat()
