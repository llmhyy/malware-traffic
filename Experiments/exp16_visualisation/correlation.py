import matplotlib.pyplot as plt
import numpy as np
from scipy import stats
from typing import Tuple, Optional, List
from entropy import BlackListProvider

from api_extraction import get_segmented_flow_syscalls
from clustering import cluster_segmented_flow, SegmentedConvertor
from comparaison_classes import CachedLCS, CachedSW, CachedCustomLCS
from segmentation import get_segmentation

TIME_DELAY_ALLOWED = 5
DEBUG_CORNER = True


def inter_cluster_sim_scores_random(api_calls_per_flow_list_cluster1: np.ndarray,
                                    api_calls_per_flow_list_cluster2: np.ndarray, segmented_flows_cluster1: np.ndarray,
                                    segmented_flows_cluster2: np.ndarray, category: bool = False) -> Tuple[
	Optional[float], Optional[float]]:
	"""
	Calculate the two scores between 2 clusters of different malwares (api call similarity score = intention and flows similarity score = similarity/appearance)
	:param api_calls_per_flow_list_cluster1:
	:param api_calls_per_flow_list_cluster2:
	:param segmented_flows_cluster1:
	:param segmented_flows_cluster2:
	:param category:
	:return:
	"""
	if category:
		api_call_sublist_index = 2
	else:
		api_call_sublist_index = 1
	intention_engine = CachedLCS(c_lib=True)
	similarity_engine = CachedCustomLCS(c_lib=True)
	# Number of api call sequence for the selected clusters
	m, n = len(api_calls_per_flow_list_cluster1), len(api_calls_per_flow_list_cluster2)
	if m == 0 or n == 0:
		return None, None
	# Number of segmented flows for the selected clusters
	a, b = len(segmented_flows_cluster1), len(segmented_flows_cluster2)
	if a == 0 or b == 0:
		return None, None
	# These numers are supposed to be the same
	if m != a or n != b:
		raise RuntimeError("Problem here : wrong arguments")
	
	# Get indexes with non-null api call sequence
	non_empty_indexes_1 = [i for i in range(len(api_calls_per_flow_list_cluster1)) if
	                       len(api_calls_per_flow_list_cluster1[i]) != 0]
	non_empty_indexes_2 = [i for i in range(len(api_calls_per_flow_list_cluster2)) if
	                       len(api_calls_per_flow_list_cluster2[i]) != 0]
	
	# Check if a flow has a non-null api call sequence
	if len(non_empty_indexes_1) == 0 or len(non_empty_indexes_2) == 0:
		return None, None
	
	# Take random flows
	i, j = np.random.choice(non_empty_indexes_1), np.random.choice(non_empty_indexes_2)
	x_api_call, y_api_call = api_calls_per_flow_list_cluster1[i][:, api_call_sublist_index], \
	                         api_calls_per_flow_list_cluster2[j][:, api_call_sublist_index]
	x_flow, y_flow = segmented_flows_cluster1[i], segmented_flows_cluster2[j]
	sim = similarity_engine.compute(x_flow, y_flow)
	intention = intention_engine.compute(x_api_call, y_api_call)
	return sim, intention


def get_malware_segmentation_cluster_sequence(path: str, malware_process_name: str):
	# Get the segmentation in flows
	segmentations, _ = get_segmentation(path=path, malware_process_name=malware_process_name)
	cluster_indexes, nb_class = cluster_segmented_flow(segmentations)
	call_dict = {k: np.empty((0, 4)) for k in range(nb_class)}
	call_dict2 = {k: [] for k in range(nb_class)}
	for i in range(len(segmentations)):
		segmentation = segmentations[i]
		cluster = cluster_indexes[i]
		syscalls = get_segmented_flow_syscalls(segmentation, malware_process_name, path=path,
		                                       time_delay_allowed=TIME_DELAY_ALLOWED)
		# if no syscall associated in current flow (segmentations[i]) of cluster cluster_indexes[i], add an empty list
		if syscalls.shape[0]:
			call_dict[cluster] = np.vstack((call_dict[cluster], syscalls))
			call_dict2[cluster].append(syscalls)
		elif len(syscalls) == 0:
			call_dict2[cluster].append(np.array([]))
		else:
			raise RuntimeError("Problem here : corner case")
	for k, v in call_dict.items():
		print(f"Cluster {k} : {v.shape}")
		sorted_indexes = np.argsort(v[:, -1])
		call_dict[k] = v[sorted_indexes]
	return segmentations, cluster_indexes, nb_class, call_dict, call_dict2


def rand_cmap(nlabels, type='bright', first_color_black=True, last_color_black=False, verbose=True):
	"""
	https://github.com/delestro/rand_cmap
    Creates a random colormap to be used together with matplotlib. Useful for segmentation tasks
    :param nlabels: Number of labels (size of colormap)
    :param type: 'bright' for strong colors, 'soft' for pastel colors
    :param first_color_black: Option to use first color as black, True or False
    :param last_color_black: Option to use last color as black, True or False
    :param verbose: Prints the number of labels and shows the colormap. True or False
    :return: colormap for matplotlib
    """
	from matplotlib.colors import LinearSegmentedColormap
	import colorsys
	import numpy as np
	
	if type not in ('bright', 'soft'):
		print('Please choose "bright" or "soft" for type')
		return
	
	if verbose:
		print('Number of labels: ' + str(nlabels))
	
	# Generate color map for bright colors, based on hsv
	if type == 'bright':
		randHSVcolors = [(np.random.uniform(low=0.0, high=1),
		                  np.random.uniform(low=0.2, high=1),
		                  np.random.uniform(low=0.9, high=1)) for i in range(nlabels)]
		
		# Convert HSV list to RGB
		randRGBcolors = []
		for HSVcolor in randHSVcolors:
			randRGBcolors.append(colorsys.hsv_to_rgb(HSVcolor[0], HSVcolor[1], HSVcolor[2]))
		
		if first_color_black:
			randRGBcolors[0] = [0, 0, 0]
		
		if last_color_black:
			randRGBcolors[-1] = [0, 0, 0]
		
		random_colormap = LinearSegmentedColormap.from_list('new_map', randRGBcolors, N=nlabels)
	
	# Generate soft pastel colors, by limiting the RGB spectrum
	if type == 'soft':
		low = 0.6
		high = 0.95
		randRGBcolors = [(np.random.uniform(low=low, high=high),
		                  np.random.uniform(low=low, high=high),
		                  np.random.uniform(low=low, high=high)) for i in range(nlabels)]
		
		if first_color_black:
			randRGBcolors[0] = [0, 0, 0]
		
		if last_color_black:
			randRGBcolors[-1] = [0, 0, 0]
		random_colormap = LinearSegmentedColormap.from_list('new_map', randRGBcolors, N=nlabels)
	
	return random_colormap


def display_debug_graph(api_call1, api_call2, flow1, flow2, category):
	plt.figure()
	color_dictionary = {
		'HANDSHAKE': 'xkcd:goldenrod',
		'TERM': 'xkcd:maroon',
		"IN": 'xkcd:green',
		'IN_TLS': 'xkcd:chartreuse',
		'OUT': 'xkcd:blue',
		'OUT_TLS': 'xkcd:sky blue',
		'TERM_RST': 'xkcd:red',
		"HANDSHAKE_FAILED": 'xkcd:purple',
		'TLS_handshake': 'tab:brown',
		'Failed_TLS_handshake': 'xkcd:crimson'
	}
	flows = [flow1, flow2]
	for i in range(len(flows)):
		plt.subplot(4, 1, i + 1)
		y = 0
		list_flows = flows[i]
		for j in range(len(list_flows)):  # For every flow ...
			for k in range(len(list_flows[j])):  # For every group of packets inside the flow ...
				color = color_dictionary.get(list_flows[j][k][0], 'tab:orange')
				plt.broken_barh(
					[(int(list_flows[j][k][1][0]), 1 + int(list_flows[j][k][1][1]) - int(list_flows[j][k][1][0]))],
					(y, 1), facecolors=color, label=list_flows[j][k][0])
				plt.xticks([], [])
			y += 1
	
	# Display api call sequences
	# TODO: get file nb of line
	plt_cmap = rand_cmap(805, type='bright', first_color_black=True, last_color_black=False)
	conv_dict = {}
	current_i = 0
	
	api_calls = [api_call1, api_call2]
	for i in range(len(api_calls)):
		plt.subplot(4, 1, i + 1 + 2)
		y = 0
		cluster_call_seq = api_calls[i]
		color_list = []
		for j in range(len(cluster_call_seq)):  # For every flow ...
			color_sublist = []
			for k in range(len(cluster_call_seq[j])):  # For every group of packets inside the flow ...
				type = cluster_call_seq[j][k][2 if category else 1]
				test2 = conv_dict.get(type, None)
				if test2 is None:
					test2 = current_i
					conv_dict[type] = current_i
					current_i += 1
				color = plt_cmap(test2)
				color_sublist.append(color)
			color_list.append(color_sublist)
		
		for j in range(len(cluster_call_seq)):
			plt.broken_barh([(k, k + 1) for k in range(len(cluster_call_seq[j]))], (j, 1), facecolors=color_list[j])
		plt.xticks([], [])
	plt.show()
	print("done\n")
	return


def correlate(list_of_paths: List):
	segmentations_list, cluster_indexes_list, nb_classes_list, call_dict1_list, call_dict2_list = [], [], [], [], []
	x_list = []
	y_list = []
	segmented_convertor = SegmentedConvertor()
	black_list_provider = BlackListProvider()
	for path in list_of_paths:
		segmentations1, cluster_indexes1, nb_class1, call_dict_1, call_dict2_1 = get_malware_segmentation_cluster_sequence(
			path, "malware.exe")
		segmentations_list.append(segmentations1)
		cluster_indexes_list.append(cluster_indexes1)
		nb_classes_list.append(nb_class1)
		call_dict1_list.append(call_dict_1)
		call_dict2_list.append(call_dict2_1)
		black_list_provider.add_malware_file(path, nb_class1, call_dict_1)
	# Segmentation list = list of segmented malwares (len = nb of malware)
	for x in range(len(segmentations_list)):
		for y in range(x):
			segmentations1, cluster_indexes1, nb_class1, call_dict_1, call_dict2_1 = segmentations_list[x], \
			                                                                         cluster_indexes_list[x], \
			                                                                         nb_classes_list[x], \
			                                                                         call_dict1_list[x], \
			                                                                         call_dict2_list[x]
			segmentations2, cluster_indexes2, nb_class2, call_dict_2, call_dict2_2 = segmentations_list[y], \
			                                                                         cluster_indexes_list[y], \
			                                                                         nb_classes_list[y], \
			                                                                         call_dict1_list[y], \
			                                                                         call_dict2_list[y]
			for i in range(nb_class1):
				for j in range(nb_class2):
					typegroups1 = segmented_convertor.segmented_to_typegroups(segmentations1)
					typegroups2 = segmented_convertor.segmented_to_typegroups(segmentations2)
					appearance, intention = inter_cluster_sim_scores_random(call_dict2_1[i], call_dict2_2[j],
					                                                        np.array(typegroups1, dtype=object)[
						                                                        cluster_indexes1 == i],
					                                                        np.array(typegroups2, dtype=object)[
						                                                        cluster_indexes2 == j], category=False)
					if intention is None or appearance is None:
						continue
					if appearance > 0.9 and intention < 0.10 and DEBUG_CORNER:
						display_debug_graph(call_dict2_1[i], call_dict2_2[j],
						                    np.array(segmentations1)[
							                    cluster_indexes1 == i],
						                    np.array(segmentations2)[
							                    cluster_indexes2 == j], category=False)
					x_list.append(appearance)
					y_list.append(intention)
	# noinspection PyTypeChecker
	pear = stats.pearsonr(x_list, y_list)
	# noinspection PyTypeChecker
	spear = stats.spearmanr(x_list, y_list)
	text = f"Pearson r={pear[0]:.4f}, pva={pear[1]:.4f}\nSpearman r={spear[0]:.4f}, pva={spear[1]:.4f}"
	
	fig = plt.figure()
	plt.xlabel("Cluster similarity\n" + text)
	plt.ylabel("API Call Sequence similarity")
	h = plt.hist2d(x_list, y_list, bins=[25, 25], range=[[0, 1], [0, 1]])
	plt.colorbar(h[3])
	plt.plot([0, 1], [0, 1], ls="--", c=".3")
	fig.subplots_adjust(bottom=0.2)
	plt.show()
	fig = plt.figure()
	plt.xlabel("Cluster similarity\n" + text)
	plt.ylabel("API Call Sequence similarity")
	plt.scatter(x_list, y_list)
	plt.xlim([0, 1])
	plt.ylim([0, 1])
	fig.subplots_adjust(bottom=0.2)
	plt.show()
	print(pear, spear)


if __name__ == "__main__":
	np.random.seed(1)
	correlate(["trickbot1_1/", "trickbot1_2/", "trickbot1_3/", "trickbot1_5/"])
	print("-------Caching------------------------------")
	CachedLCS().print_stat()
	CachedCustomLCS().print_stat()
	CachedSW().print_stat()
