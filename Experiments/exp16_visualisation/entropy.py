import matplotlib.pyplot as plt
import numpy as np
from collections import Counter

from api_extraction import Singleton


class BlackListProvider(metaclass=Singleton):
	def __init__(self):
		self.malware_black_dict = {}
	
	def add_malware_file(self, malware_name, nb_class1, call_dict_1):
		api_set = set()
		api_dict = {}
		counter_list = []
		for i in range(nb_class1):
			raw_list = call_dict_1[i]
			api_list = np.array(raw_list)[:, 1]
			counter_list.append(Counter(api_list))
			api_set.update(set(api_list))
			# TODO: awkward
			for api in api_list:
				if api in api_dict:
					api_dict[api] += 1
				else:
					api_dict[api] = 1
		
		api_set = list(api_set)
		entropy_list = []
		for api_fun_name in api_set:
			total_fun_nb = api_dict[api_fun_name]
			entropy = 0
			for i in range(nb_class1):
				nb_of_fun_in_cluster = counter_list[i][api_fun_name]
				p = nb_of_fun_in_cluster / total_fun_nb
				if p == 0:
					continue
				entropy -= p * np.log2(p)
			entropy_list.append(entropy / np.log2(nb_class1))
		
		self.malware_black_dict[malware_name] = (api_set, entropy_list)
	
	def display_cluster_api_calls_entropy(self, malware_name):
		plt.figure()
		api_set, entropy_list = self.malware_black_dict[malware_name]
		plt.scatter(range(len(entropy_list)), entropy_list)
		plt.title(f'API functions and their entropy in current malware clusters {malware_name}')
		plt.show()
		
		to_disp_array = [(a, b) for a, b in zip(api_set, entropy_list) if b > 0.8]
		to_disp_array.sort(key=lambda x: x[1], reverse=True)
		to_disp_array = to_disp_array[:30] if len(to_disp_array) >= 30 else to_disp_array
		
		fig, ax = plt.subplots()
		ax.barh(range(len(to_disp_array)), [a[1] for a in to_disp_array], align='center')
		ax.set_yticks(range(len(to_disp_array)))
		ax.set_yticklabels([a[0] for a in to_disp_array])
		ax.invert_yaxis()
		ax.set_xlabel('Entropy')
		ax.set_title(f'API functions and their entropy in current malware clusters {malware_name}')
		fig.subplots_adjust(left=0.3)
		plt.show()
	
	def get_blacklist(self):
		list_of_high_entorpy_calls = []
		for mal_name, info in self.malware_black_dict.items():
			api_set, entropy_list = info
			ret_array = self.get_top_entropy_calls(30, api_set, entropy_list)
			list_of_high_entorpy_calls += ret_array
		counter = Counter([a[0] for a in list_of_high_entorpy_calls])
		# TODO: maybe adapt this part when using malwares from diff families etc
		# It's now taking all api calls with high entropy, but it could be calls specifics to one family
		return [u for u, v in counter.items() if v >= 3]
	
	@staticmethod
	def get_top_entropy_calls(n, api_set, entropy_list):
		to_disp_array = [(a, b) for a, b in zip(api_set, entropy_list) if b > 0.8]
		to_disp_array.sort(key=lambda x: x[1], reverse=True)
		to_disp_array = to_disp_array[:n] if len(to_disp_array) >= n else to_disp_array
		return to_disp_array


if __name__ == '__main__':
	# FIXME: test impossible due to circular imports
	pass
